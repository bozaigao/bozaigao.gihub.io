<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自律则自由</title>
  
  <subtitle>仰望星空的同时不忘脚踏实地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bozaigao.github.io/"/>
  <updated>2021-02-10T11:57:51.533Z</updated>
  <id>http://bozaigao.github.io/</id>
  
  <author>
    <name>何晏波</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Charles进行Android和iOS抓包</title>
    <link href="http://bozaigao.github.io/2021/02/10/%E4%BD%BF%E7%94%A8Charles%E8%BF%9B%E8%A1%8CAndroid%E5%92%8CiOS%E6%8A%93%E5%8C%85/"/>
    <id>http://bozaigao.github.io/2021/02/10/使用Charles进行Android和iOS抓包/</id>
    <published>2021-02-10T01:48:20.000Z</published>
    <updated>2021-02-10T11:57:51.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>web前端的话可以直接使用Chrome的dev-tools进行网络请求等数据分析，那么app移动端为了更好的和后端进行联调，遇到接口调用报错的时候后端经常需要前端发送curl给他们进行排查，这时候就需要使用抓包工具对http和https进行抓包分析了，以下以常用的Charles抓包工具为例，演示在Android和iOS如何进行抓包。</p><h4 id="Charles下载以及安装配置（已安装的请忽略该步骤）"><a href="#Charles下载以及安装配置（已安装的请忽略该步骤）" class="headerlink" title="Charles下载以及安装配置（已安装的请忽略该步骤）"></a>Charles下载以及安装配置（已安装的请忽略该步骤）</h4><ul><li>安装包下载地址（选择对应的平台进行下载即可）<ul><li><a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">https://www.charlesproxy.com/download/</a></li></ul></li><li>下载破解文件<ul><li><a href="https://assets.examplecode.cn/file/charles.jar" target="_blank" rel="noopener">https://assets.examplecode.cn/file/charles.jar</a></li><li>打开Finder,在应用程序中选择Charles并右键选择显示包内容</li><li>显示包内容后在Content/Java目录下将破解文件复制过来替换掉原文件即可</li><li>如果打开Charles时提示：程序已损坏，打不开。您应该将它移到废纸篓。此时需要在终端中执行以下命令即可：sudo spctl –master-disable</li></ul></li><li>抓包代理设置<ul><li>可以设置抓包数据类型，包括http与socket数据。可以根据需要在proxies栏下勾选。这里简单操作进行设置，Proxy —&gt; Proxy Settings默认端口是8888，根据实际情况可修改。<br><img src="/assets/zhuabao_setting1.png" alt=""></li><li>如何是抓https协议的包就还需要选择SSL Proxying Settins进行设置<br><img src="/assets/zhuabao_setting2.png" alt=""></li></ul></li><li>电脑安装证书<ul><li>help —&gt; SSl Proxying —&gt; install charles root certificate —&gt; 安装证书</li></ul></li></ul><h4 id="Android抓包配置"><a href="#Android抓包配置" class="headerlink" title="Android抓包配置"></a>Android抓包配置</h4><ul><li>然后抓包试一下，会发现Android7.0手机之前可以抓包，但是Android7.0之后是无法抓包的<ul><li>报错信息：客户端SSL握手失败:处理证书时出现未知问题(certificate_unknown)<br><img src="/assets/charles_android_1.png" alt=""></li></ul></li><li>手机上需要安装证书<ul><li>第一步下载证书<ul><li>打开浏览器，输入：<strong>chls.pro/ssl</strong>，就会自己下载到手机上，这里需要记住下载完成保存到本地的路径</li></ul></li><li>第二步安装证书<ul><li>设置 —&gt; 更多设置 —&gt; 系统安全 —&gt; 加密与凭据 —&gt; 从SD卡安装，选择之前保存证书的路径</li><li>有的手机是直接点击下载的文件即可安装……</li><li>主意这里有一个小坑那就是安装证书的时候<strong>凭据用途</strong>一定要选择<strong>VPN和应用</strong>，笔者在这里试了很多次最终对比HttpCanary证书的安装方式才发现这个问题。。。<blockquote><p>HttpCanary是一个Android app，也可以通过它进行手机流量监控和抓包<br><img src="/assets/charles_user_pingzheng.png" alt=""></p></blockquote></li><li>如果选择了<strong>用于WLAN</strong>那么用户受信任证书列表中将不会出现我们的安装证书<br><img src="/assets/charles_user_pingzheng2.png" alt=""></li></ul></li></ul></li><li>Android项目代码设置兼容<ul><li>添加安全配置文件。如下所示：</li><li>java.security.cert.CertPathValidatorException: Trust anchor for certification path not found 这个异常，解决方案如下所示：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">certificates</span></span></span><br><span class="line"><span class="tag">             <span class="attr">overridePins</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">src</span>=<span class="string">"system"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">certificates</span></span></span><br><span class="line"><span class="tag">             <span class="attr">overridePins</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">src</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">//清单文件配置</span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config_debug"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>修改wifi网络<ul><li>和Charles电脑保持在相同的局域网然后长按wifi修改网络然后选择手动代理输入电脑ip和端口号8888(默认)</li></ul></li><li>HttpCanary<ul><li>HttpCanary是Android平台下的一款流量监控和抓包工具，安装步骤简单，也可以直接使用它进行抓包分析，缺点就是不能直接复制curl，而Charles直接在请求路径右键点击选择Copy cURL Request即可看到的抓包数据也更多一些。<br><img src="/assets/HttpCanary.png" alt=""></li></ul></li></ul><h4 id="iOS抓包配置"><a href="#iOS抓包配置" class="headerlink" title="iOS抓包配置"></a>iOS抓包配置</h4><ul><li>使用Safari浏览器访问<strong>chls.pro/ssl</strong>下载证书</li><li>到Settings-&gt;General-&gt;Profile找到之前下载的证书点击进行安装<br><img src="/assets/Chales_ios1.png" alt=""></li><li>到Settings-&gt;General-&gt;About-&gt;Certificate Trust Settings找到Charles证书设置为信任<br><img src="/assets/Chales_ios2.png" alt=""><blockquote><p>笔者当初就是少了信任证书这一步导致iOS在开启代理后一直网络请求失败</p></blockquote></li></ul><h4 id="Chales抓包原理"><a href="#Chales抓包原理" class="headerlink" title="Chales抓包原理"></a>Chales抓包原理</h4><p> <img src="/assets/Charles_yuanli.png" alt=""></p><h4 id="如何避免被抓包"><a href="#如何避免被抓包" class="headerlink" title="如何避免被抓包"></a>如何避免被抓包</h4><ul><li>基于抓包原理的基础上，直接使用okhtttp禁止代理，就可以了 builder.proxy(Proxy.NO_PROXY);经过测试，可以避免抓包</li><li>直接使用加密协议https，全是字段乱码， 把域名换装IP。这样基本别人很难抓到，像混淆一样</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;web前端的话可以直接使用Chrome的dev-tools进行网络请求等数据分析，那么app移动端为了更好的和后端进行联调，遇到接口调用报错
      
    
    </summary>
    
    
      <category term="抓包" scheme="http://bozaigao.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
      <category term="Charles" scheme="http://bozaigao.github.io/tags/Charles/"/>
    
      <category term="抓包" scheme="http://bozaigao.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>手写代码实现Redux、React-Redux以及中间件功能</title>
    <link href="http://bozaigao.github.io/2020/07/30/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0Redux%E3%80%81React-Redux%E4%BB%A5%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8A%9F%E8%83%BD/"/>
    <id>http://bozaigao.github.io/2020/07/30/手写代码实现Redux、React-Redux以及中间件功能/</id>
    <published>2020-07-30T11:51:12.000Z</published>
    <updated>2020-08-02T12:13:23.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Redux是一个javascript应用的状态容器，它能保证程序行为的一致性且易于测试，它使我们在项目开发中能够更方便的管理应用状态，所以我们在项目中需要使用它，如果我们是React应用的话那我们应该用到的数据流管理组件应该就是react-redux，而react-redux是基于redux的，所以下面实现了redux以及react-redux相关的一些功能。</p><h3 id="Redux工作流程如下："><a href="#Redux工作流程如下：" class="headerlink" title="Redux工作流程如下："></a>Redux工作流程如下：<img src="/assets/react/ico_redux_flow.jpg" alt=""></h3><p>描述：首先我们的应用界面根据store.getState()将数据和UI做了绑定，并在生命周期函数内部订阅了store更新通知，此时当用户在我们的应用界面上进行交互触发了操作这时候会通过store调用里面定义的dispatch api方法传递是plain object的action，然后在dispatch内部通过调用我们业务端定义的reducer传入state和action返回new state，最后依次执行订阅了store更新的listener，在应用内部通过触发forceUpdate最终完成store的整个更新流程。</p><h3 id="实现createStore"><a href="#实现createStore" class="headerlink" title="实现createStore"></a>实现createStore</h3><figure class="highlight js"><figcaption><span>creatStore.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState, currentListeners = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        currentState = reducer(currentState, action)</span><br><span class="line">        <span class="built_in">console</span>.log(currentState);</span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        currentListeners.push(cb)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index = currentListeners.indexOf(cb)</span><br><span class="line">            currentListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'NO_EXIT'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">这里面主要实现了getState、dispatch、subscribe三个方法。</span><br></pre></td></tr></table></figure><h3 id="实现applyMiddleware"><a href="#实现applyMiddleware" class="headerlink" title="实现applyMiddleware"></a>实现applyMiddleware</h3><figure class="highlight js"><figcaption><span>applyMiddleware.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...midlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> api = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> middlewareChain = midlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(api))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dispatch = compose(...middlewareChain)(dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">args</span> =&gt;</span> args;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> funs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重要的一个函数是compose，实现了函数的合成主要是基于js Array原型里面的reduce函数来实现,<br>JS数组reduce()方法<br>arr.reduce(function(prev,cur,index,arr){<br>…<br>}, init);<br>或者<br>arr.reduce(function(prev,cur,index,arr){<br>…<br>},);<br>arr 表示原数组；<br>prev 表示上一次调用回调时的返回值，或者初始值 init;<br>cur 表示当前正在处理的数组元素；<br>index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；<br>init 表示初始值。<br>常用的参数只有两个：prev 和 cur。<br>如果读者对reduce不熟悉的话可以先看看下面关于reduce的例子</p><h4 id="1-reduce实现数组去重"><a href="#1-reduce实现数组去重" class="headerlink" title="1.reduce实现数组去重"></a>1.reduce实现数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组求和，求乘积</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">  <span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line">  <span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y)</span><br><span class="line">  <span class="built_in">console</span>.log(sum); <span class="comment">//求和，10</span></span><br><span class="line">  <span class="built_in">console</span>.log(mul); <span class="comment">//求乘积，24</span></span><br></pre></td></tr></table></figure><h4 id="2-reduce计算数组中每个元素出现的次数"><a href="#2-reduce计算数组中每个元素出现的次数" class="headerlink" title="2.reduce计算数组中每个元素出现的次数"></a>2.reduce计算数组中每个元素出现的次数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算数组中每个元素出现的次数</span></span><br><span class="line">  <span class="keyword">let</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nameNum = names.reduce(<span class="function">(<span class="params">pre, cur, index, arrar</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">      pre[cur]++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre[cur] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(nameNum); <span class="comment">//&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-reduce计数组去重"><a href="#3-reduce计数组去重" class="headerlink" title="3.reduce计数组去重"></a>3.reduce计数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> quchong = array.reduce(<span class="function">(<span class="params">pre, cur, index, arrar</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre.indexOf(cur) === <span class="number">-1</span>) &#123;</span><br><span class="line">      pre.push(cur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数组去重复'</span>, quchong);</span><br></pre></td></tr></table></figure><h4 id="4-reduce二维数组转化为一维"><a href="#4-reduce二维数组转化为一维" class="headerlink" title="4.reduce二维数组转化为一维"></a>4.reduce二维数组转化为一维</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将二维数组转化为一维</span></span><br><span class="line"><span class="keyword">let</span> array1 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">  <span class="keyword">let</span> yiwei = array1.reduce(<span class="function">(<span class="params">pre, cur, index, arrar</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index, arrar);</span><br><span class="line">    <span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'一维'</span>, yiwei);</span><br></pre></td></tr></table></figure><h4 id="5-reduce将多维数组转化为一维"><a href="#5-reduce将多维数组转化为一维" class="headerlink" title="5.reduce将多维数组转化为一维"></a>5.reduce将多维数组转化为一维</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将多维数组转化为一维</span></span><br><span class="line"><span class="keyword">let</span> array2 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]];</span><br><span class="line">  <span class="keyword">let</span> newArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? newArray(cur) : cur), [])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'多维'</span>, newArray(array2));</span><br></pre></td></tr></table></figure><h4 id="6-reduce对象里的属性求和"><a href="#6-reduce对象里的属性求和" class="headerlink" title="6.reduce对象里的属性求和"></a>6.reduce对象里的属性求和</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将多维数组转化为一维</span></span><br><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">      subject: <span class="string">'math'</span>,</span><br><span class="line">      score: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      subject: <span class="string">'chinese'</span>,</span><br><span class="line">      score: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      subject: <span class="string">'english'</span>,</span><br><span class="line">      score: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(sum) <span class="comment">//60</span></span><br></pre></td></tr></table></figure><h3 id="中间件实现"><a href="#中间件实现" class="headerlink" title="中间件实现"></a>中间件实现</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">&#123; getState &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行logger'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"*******************************"</span>, next); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(action.type + <span class="string">"执行了！"</span>); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prevState = getState();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"prev state"</span>, prevState); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> returnValue = next(action);</span><br><span class="line">    <span class="keyword">let</span> nextState = getState();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"next state"</span>, nextState); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"*******************************"</span>); <span class="comment">//sy-log</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !next就是聚合函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行thunk'</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">&#123; dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行promise'</span>);</span><br><span class="line">    <span class="keyword">return</span> isPromise(action) ? action.then(dispatch) : next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仓库地址：<a href="https://github.com/bozaigao/my-react-redux" target="_blank" rel="noopener">https://github.com/bozaigao/my-react-redux</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Redux是一个javascript应用的状态容器，它能保证程序行为的一致性且易于测试，它使我们在项目开发中能够更方便的管理应用状态，所以我
      
    
    </summary>
    
    
      <category term="Redux" scheme="http://bozaigao.github.io/categories/Redux/"/>
    
      <category term="React-Redux" scheme="http://bozaigao.github.io/categories/Redux/React-Redux/"/>
    
      <category term="中间件" scheme="http://bozaigao.github.io/categories/Redux/React-Redux/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redux" scheme="http://bozaigao.github.io/tags/Redux/"/>
    
      <category term="React-Redux" scheme="http://bozaigao.github.io/tags/React-Redux/"/>
    
      <category term="中间件" scheme="http://bozaigao.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Js前端模块化规范</title>
    <link href="http://bozaigao.github.io/2020/07/21/js_standard/"/>
    <id>http://bozaigao.github.io/2020/07/21/js_standard/</id>
    <published>2020-07-21T01:10:44.000Z</published>
    <updated>2020-07-21T02:50:42.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为前端如果你没有细致研究对比过js模块化规范的话，也许有时候你会对js模块的不同引用方式有点懵逼，也许你听说过<strong>commonJS</strong>、<strong>AMD</strong>、<strong>CMD</strong>、<strong>UMD</strong>、<strong>ESM</strong>、<strong>cjs</strong>等名词但是搞不懂它们什么意思，下面将细致的对这些js模块的规范进行阐述。</p><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>模块化在项目中十分的重要，一个复杂的项目肯定有很多相似的功能模块，如果每次都需要重新编写模块肯定既费时又耗力。但是引用别人编写模块的前提是要有统一的“打开姿势”，如果每个人有各自的写法，那么肯定会乱套，如是产生了模块化规范来对模块的构建和引用进行约束。</p><h3 id="1-CommonJS规范-同步加载模块-别名cjs"><a href="#1-CommonJS规范-同步加载模块-别名cjs" class="headerlink" title="1. CommonJS规范(同步加载模块,别名cjs)"></a>1. CommonJS规范(同步加载模块,别名cjs)</h3><ul><li>允许模块以require的方式<strong>同步加载</strong>其他模块,然后通过exports和module.exports的形式向外暴露接口。</li><li>使用方式如下，如果只是对外暴露一些属性或者方法用exports，如果要暴露一个对象（包含属性和方法）则使用module.exports。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//导入</span></span><br><span class="line"> <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line"> <span class="built_in">require</span>(<span class="string">'./app.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line">exports.getSomethInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;someValue,someFunction&#125;</span><br></pre></td></tr></table></figure></li><li>优点<ul><li>简单易用</li><li>服务端的模块便于复用</li></ul></li><li>缺点<ul><li>同步加载在浏览器端不适用，会阻碍加载，浏览器资源是异步加载的</li><li>不能非阻塞并行加载多个模块</li></ul></li><li>为什么服务端可以使用同步加载而浏览器端就不行？<ul><li>因为模块都放在服务端，对于服务端来说加载时间更短</li><li>浏览器端因为模块都放在服务端所以加载时间受网速等影响只能使用异步加载</li></ul></li><li>CommonJS规范代表node.js的模块系统，在node里面实现了moduel、exports、require、global四个变量。</li></ul><h3 id="2-AMD（异步加载模块）"><a href="#2-AMD（异步加载模块）" class="headerlink" title="2. AMD（异步加载模块）"></a>2. AMD（异步加载模块）</h3><ul><li>采用异步方式加载模块，模块的加载不影响后面语句的运行。所有依赖模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行。</li><li>使用实例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 定义</span></span><br><span class="line">define(<span class="string">"module"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;...&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../app"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, app</span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></li><li>加载模块require([module], callback);第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback是加载成功之后的回调函。</li><li>优点<ul><li>适合在浏览器环境中异步加载模块</li><li>可以并行加载多个模块</li></ul></li><li>缺点<ul><li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li><li>不符合通用的模块化思维方式，是一种妥协的实现</li></ul></li><li>AMD规范代表<font color='blue'><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">requirejs</a></font>。</li></ul><h3 id="3-CMD规范（异步加载模块）"><a href="#3-CMD规范（异步加载模块）" class="headerlink" title="3. CMD规范（异步加载模块）"></a>3. CMD规范（异步加载模块）</h3><ul><li>CMD规范和AMD很相似，简单，并与CommonJS和Node.js的 Modules 规范保持了很大的兼容性；在CMD规范中，一个模块就是一个文件。</li><li>定义模块使用全局函数define，其接收 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串；</li><li>factory 是一个函数，有三个参数，function(require, exports, module)：<ul><li>require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)</li><li>exports 是一个对象，用来向外提供模块接口</li><li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li></ul></li><li>实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>优点<ul><li>依赖就近，延迟执行</li><li>可以很容易在 Node.js 中运行</li></ul></li><li>缺点<ul><li>依赖 SPM 打包，模块的加载逻辑偏重</li><li>实现代表库<font color='blue'><a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a></font>：SeaJS对模块的态度是懒执行, SeaJS只会在真正需要使用(依赖)模块时才执行该模块</li></ul></li></ul><h3 id="4-UMD规范（AMD和CommonJS的糅合）"><a href="#4-UMD规范（AMD和CommonJS的糅合）" class="headerlink" title="4. UMD规范（AMD和CommonJS的糅合）"></a>4. UMD规范（AMD和CommonJS的糅合）</h3><ul><li>AMD 以浏览器第一原则发展异步加载模块</li><li>CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装</li><li>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式；在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    </span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">window</span>.eventUtil = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-ES6模块化"><a href="#5-ES6模块化" class="headerlink" title="5. ES6模块化"></a>5. ES6模块化</h3><ul><li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</li><li>ES6 模块设计思想：尽量的静态化、使得编译时就能确定模块的依赖关系，以及输入和输出的变量（CommonJS和AMD模块，都只能在运行时确定这些东西）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"/app"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> “react”;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> “react”;</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">2018</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>优点<ul><li>容易进行静态分析</li><li>面向未来的 EcmaScript 标准</li></ul></li><li>缺点<ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令字，新版的 Node.js才支持</li></ul></li></ul><h3 id="谈谈“require与import的区别”"><a href="#谈谈“require与import的区别”" class="headerlink" title="谈谈“require与import的区别”"></a>谈谈“require与import的区别”</h3><ul><li>require使用与CommonJs规范，import使用于Es6模块规范；所以两者的区别实质是两种规范的区别；</li><li><strong>ComonJS</strong><ul><li>对于基本数据类型，属于复制。即会被模块缓存；同时，在另一个模块可以对该模块输出的变量重新赋值。</li><li>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。</li><li>当使用require命令加载某个模块时，就会运行整个模块的代码。</li><li>当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li><li>循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul></li><li><strong>ES6模块</strong><ul><li>对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。</li><li>循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。</li></ul></li><li><strong>总结：require/exports 是必要通用且必须的；因为事实上，目前你编写的 import/export 最终都是编译为 require/exports 来执行的。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为前端如果你没有细致研究对比过js模块化规范的话，也许有时候你会对js模块的不同引用方式有点懵逼，也许你听说过&lt;strong&gt;common
      
    
    </summary>
    
    
      <category term="js规范" scheme="http://bozaigao.github.io/categories/js%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="js规范" scheme="http://bozaigao.github.io/tags/js%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>vue源码剖析</title>
    <link href="http://bozaigao.github.io/2020/07/13/vue_source_analysis/"/>
    <id>http://bozaigao.github.io/2020/07/13/vue_source_analysis/</id>
    <published>2020-07-13T11:49:26.000Z</published>
    <updated>2020-07-21T01:12:05.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言-vue版本基于2-6-11"><a href="#前言-vue版本基于2-6-11" class="headerlink" title="前言(vue版本基于2.6.11)"></a>前言(vue版本基于2.6.11)</h3><p>学习一门框架的最好方式就是进行源码剖析，只有从源码角度去窥探vue的运行原理才能对vue的开发更加得心应手，对框架的运行机制才能更了然于心。</p><h3 id="1-vue源码目录层级"><a href="#1-vue源码目录层级" class="headerlink" title="1.vue源码目录层级"></a>1.vue源码目录层级</h3><p> <img src="/assets/vue/vue_source1.jpg" alt=""><br> <img src="/assets/vue/vue_source2.jpg" alt=""></p><h3 id="2-调试环境搭建"><a href="#2-调试环境搭建" class="headerlink" title="2.调试环境搭建"></a>2.调试环境搭建</h3><h4 id="2-1-安装依赖"><a href="#2-1-安装依赖" class="headerlink" title="2.1 安装依赖"></a>2.1 安装依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><h4 id="2-2-全局安装rollup-js打包工具"><a href="#2-2-全局安装rollup-js打包工具" class="headerlink" title="2.2 全局安装rollup js打包工具"></a>2.2 全局安装rollup js打包工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g rollup</span><br></pre></td></tr></table></figure><h4 id="2-3-修改package-json打包脚本"><a href="#2-3-修改package-json打包脚本" class="headerlink" title="2.3 修改package.json打包脚本"></a>2.3 修改package.json打包脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"</span></span><br></pre></td></tr></table></figure><blockquote><p>这里增加了 <strong>–sourcemap</strong>配置，这样设置主要的目的是在后面调试的时候可以直接根据.js.map源码映射关系直接定位到源码文件在文件目录树中的位置，方便后面自己对应着进行源码位置查找与阅读。</p></blockquote><h4 id="2-4-打包生成js库"><a href="#2-4-打包生成js库" class="headerlink" title="2.4 打包生成js库"></a>2.4 打包生成js库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h4 id="2-5-引用我们上面打包好的vue-js进行调试"><a href="#2-5-引用我们上面打包好的vue-js进行调试" class="headerlink" title="2.5 引用我们上面打包好的vue.js进行调试"></a>2.5 引用我们上面打包好的vue.js进行调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"../../dist/vue.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-入口文件"><a href="#3-入口文件" class="headerlink" title="3.入口文件"></a>3.入口文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'web-full-dev'</span>: &#123;</span><br><span class="line">   entry: resolve(<span class="string">'web/entry-runtime-with-compiler.js'</span>),</span><br><span class="line">   dest: resolve(<span class="string">'dist/vue.js'</span>),</span><br><span class="line">   format: <span class="string">'umd'</span>,</span><br><span class="line">   env: <span class="string">'development'</span>,</span><br><span class="line">   alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</span><br><span class="line">   banner</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从script/config.js里面web-full-dev可以看出我们要打包的对应平台版本的入口文件是<strong>entry-runtime-with-compiler.js</strong></p><h3 id="4-vue初始化流程（下面将以源码的执行顺序为目录进行分析）"><a href="#4-vue初始化流程（下面将以源码的执行顺序为目录进行分析）" class="headerlink" title="4.vue初始化流程（下面将以源码的执行顺序为目录进行分析）"></a>4.vue初始化流程（下面将以源码的执行顺序为目录进行分析）</h3><h4 id="4-1-思维导图"><a href="#4-1-思维导图" class="headerlink" title="4.1 思维导图"></a>4.1 思维导图</h4><p><img src="/assets/vue/vue_lifecycle.png" alt=""></p><h4 id="4-2-src-core-index-js"><a href="#4-2-src-core-index-js" class="headerlink" title="4.2 src/core/index.js"></a>4.2 <strong>src/core/index.js</strong></h4><p>在这个文件里面调用inintGlobalAPI方法来初始化全局api，比如set、delete、nextTick等，其中比较重要的是调用了initAssetRegisters这个函数，这个函数从src/core/global-api/assets.js文件里面导入，主要功能是遍历’component’、’directive’、’filter’生成全局注册方法并挂载到Vue.options上面，以’component’为例，通过this.options._base.extend(definition)调用生成组件的构造函数并在options进行挂载，例如我们使用Vue.component方法在全局申明的组件就会生成类似于<strong>this.options = {components:{‘comp’:comp构造函数}}</strong>这样的数据，后面在调用createElement生成元素虚拟节点的时候就会根据全局的options里面的组件id获取到组件的构造函数进而使用这个构造函数传入createComponent生成最终的component VNode。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'comp'</span>, &#123;</span><br><span class="line">          template: <span class="string">'&lt;div&gt;I am comp&lt;/div&gt;'</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="4-3-src-core-instance-init-js"><a href="#4-3-src-core-instance-init-js" class="headerlink" title="4.3 src/core/instance/init.js"></a>4.3 <strong>src/core/instance/init.js</strong></h4><p>组件初始化会调用_init函数，在这个函数里面依次调用了下面函数：<br><strong>initLifecycle</strong><br>这里面主要是对$parent/$root/$children进行了一系列初始化<br><strong>initEvents</strong><br>事件监听<br><strong>initRender</strong><br>createElement方法进行挂载vm.$createElement和vm._c<br><strong>callHook(vm, ‘beforeCreate’)</strong><br>组件创建之前钩子调用<br><strong>initInjections</strong><br>注入祖辈传递的数据<br><strong>initState(<font color='red'>重要</font>)</strong><br>这里面最重要的功能是实现数据的响应式，调用后会生成Observer实例，而Observer实例是在src/core/observer/index.js文件里面进行的定义，这里面针对对象数据的传入会遍历key值然后挨个调用defineReactive</p><figure class="highlight js"><figcaption><span>observer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// dep n:n watcher</span></span><br><span class="line">        <span class="comment">// 组件内会有很多key，所以一个watcher会有多个dep</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="comment">// 如果存在子ob：主要用于未来对象可能有属性增删，数组会有元素增删</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 对象内部小管家要和当前watcher建立关系</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个函数内部最终会调用js的原生函数Object.defineProperty来实现数据的响应式,在这里面重写了get和set两个方法，当数据一开始被设置的时候调用get方法在里面调用addDep完成Dep大管家和Watcher的绑定关系，如果对象data里面的value值也是一个对象则完成小管家dep和Watcher的绑定关系，最终在数据通过set方法进行变更的时候调用里面的dep.notify Watcher将执行更新操作,然后将执行quequeqWatcher=&gt;flashSchedulerQueque最终实现异步更新操作，具体流程见下面思维导图：<br><img src="/assets/vue/vue_source3.png" alt=""><br><strong>initProvide</strong><br>处理祖辈传入的数据和属性<br><strong>callHook(vm, ‘created’)</strong><br>创建成功钩子回调</p><h4 id="4-4-src-platforms-web-entry-runtime-with-compiler-js"><a href="#4-4-src-platforms-web-entry-runtime-with-compiler-js" class="headerlink" title="4.4 src/platforms/web/entry-runtime-with-compiler.js"></a>4.4 <strong>src/platforms/web/entry-runtime-with-compiler.js</strong></h4><p>这个文件里面主要在Vue的prototype上面挂载了$mount的全局方法，在这个函数里面最重要的功能是返回了render渲染函数：</p><figure class="highlight js"><figcaption><span>entry-runtime-with-compiler.js中关键代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>所谓渲染函数指的是在src/compiler/index.js文件里定义的createCompiler方法中把vue文件里面的template模板经过parse解析为AST抽象语法树以及generate生成code string后经过new Function包裹一层后可以执行的函数，这个过程就是vue的编译过程，生成的渲染函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous(</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"id"</span>:<span class="string">"demo"</span>&#125;&#125;,[_c(<span class="string">'h1'</span>,[_v(<span class="string">"Vue组件化机制"</span>)]),_v(<span class="string">" "</span>),_c(<span class="string">'comp'</span>)],<span class="number">1</span>)&#125;</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure><p>同时在函数的末尾调用了$mount方法，而$mount方法其实最开始是定义在src/platforms/web/runtime/index.js里面，这个函数里面调用了src/core/instance/lifecycle.js里面的mountComponent方法,整个流程就是获取了render渲染函数后就开始调用mountComponent这个方法，而在mountComponent方法里面则通过Watcher调用了_render,_render函数是在src/core/instance/render.js中定义的，这里面主要的作用是将crateElement作为参数传入后执行options中的render渲染函数，渲染函数中的_c方法在render.js中有定义其实就是传入的createElment方法</p><figure class="highlight js"><figcaption><span>render.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>其他符号如_v等在src/core/instance/render-helpers/index.js文件里面可以找到对应的函数，最终执行的渲染函数实际上就是如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous(</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> createElement(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"id"</span>:<span class="string">"demo"</span>&#125;&#125;,[createElement(<span class="string">'h1'</span>,[createTextVNode(<span class="string">"Vue组件化机制"</span>)]),createTextVNode(<span class="string">" "</span>),createElement(<span class="string">'comp'</span>)],<span class="number">1</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行$mount方法的时候src/core/instance/lifecycle.js里面的mountComponent会被执行，然后这里面的updateComponent方法里面的render渲染函数将会被Watcher触发，然后就会调用src/core/vdom/create-element.js里面的createElement函数进行虚拟节点VNode的创建。</p><h4 id="4-5-src-core-vdom-create-element-js"><a href="#4-5-src-core-vdom-create-element-js" class="headerlink" title="4.5 src/core/vdom/create-element.js"></a>4.5 <strong>src/core/vdom/create-element.js</strong></h4><p>这里面会根据传入的到底是系统保留标签还是自定义组件进行分别处理，如果是系统保留标签则生成系统标签对应的VNode，如果是自定义组件则会调用src/core/vdom/create-component.js里面的createComponent函数。</p><h4 id="4-6-src-core-vdom-create-component-js"><a href="#4-6-src-core-vdom-create-component-js" class="headerlink" title="4.6 src/core/vdom/create-component.js"></a>4.6 <strong>src/core/vdom/create-component.js</strong></h4><p>这个方法里面会要求传入一个自定义组件的Ctor构造函数，这个函数是在createElment里面通过resolveAsset方法传入，以Comp组件为例，则是以this.$options.components.Comp的形式获取到组件的构造函数，组件的构造函数在$options的挂载在以上4.2节inintGlobalAPI的时候有说明，至此将生成组件的VNode予以返回，当然在这里还有一个重要的伏笔那就是在返回虚拟节点之前还调用了installComponentHooks这个函数，在data里面安装了组件生命周期的函数钩子componentVNodeHooks，里面包含init、prepatch、insert、destroy，其中最重要的是init函数，这在后面执行patch实例化组件的时候将会调用这个初始化钩子，render函数最终生成VNode后将会执行src/core/instance/lifecycle.js里面的_update函数，最终调用src/core/vdom/patch.js里面的patch函数进行diff打补丁更新操作。</p><h4 id="4-7-src-core-vdom-patch-js"><a href="#4-7-src-core-vdom-patch-js" class="headerlink" title="4.7 src/core/vdom/patch.js"></a>4.7 <strong>src/core/vdom/patch.js</strong></h4><p>在patch里面将会传入虚拟节点调用createElm方法，这里也会根据元素的类型进行分别处理，如果是系统保留标签则直接初始化并插入父元素，如果是组件则会调用createComponent方法，在方法里面会根据4.6中安装的组件生命周期函数钩子函数的init方法来初始化组件，注意这里的createComponent和4.6中的createComponent不一样，虽然方法同名但是功能不同，一个是生成VNode，一个是生成实例化组件，在componentVNodeHooks的init里面又调用了child.$mount方法，于是将重复4.3步骤直到递归没有子组件为止,具体流程见最开始的vue初始化思维导图,如果是首次更新那么直接会实例化组件，并进行挂载除开首次更新外组件补丁的过程其实就是执行patchVnode首尾双循环的一个比较过程，这个过程用到了diff算法，在Vue2.0版本中一个组件对应一个Watcher,当有数据更新的时候Watcher会负责整个组件的回调更新，但是对于组件内部的子组件树的更新则依赖于diff算法，使用diff算法可以计算两次修改的最小更新，从而能够提高界面的渲染效率，整个算法描述如下：</p><figure class="highlight js"><figcaption><span>patch.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环条件：开始游标只要超过结束游标</span></span><br><span class="line">   <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">     <span class="comment">// 游标位置调整</span></span><br><span class="line">     <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">       <span class="comment">// 首尾判断开始</span></span><br><span class="line">       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 首尾都没找到相同的，从新数组头一个拿出来，去老数组中寻找相同的</span></span><br><span class="line">       <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       idxInOld = isDef(newStartVnode.key)</span><br><span class="line">         ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">         : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">         <span class="comment">// 没找到，创建追加</span></span><br><span class="line">         createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 找到了，对两者打补丁</span></span><br><span class="line">         vnodeToMove = oldCh[idxInOld]</span><br><span class="line">         <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">           patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">           oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">           <span class="comment">// 同时要做移动操作</span></span><br><span class="line">           canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">           createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h5 id="4-7-1-VNode之首尾相同"><a href="#4-7-1-VNode之首尾相同" class="headerlink" title="4.7.1 VNode之首尾相同"></a>4.7.1 <strong>VNode之首尾相同</strong></h5><p><img src="/assets/vue/diff_1.png" alt=""></p><h5 id="4-7-2-VNode之新尾部节点和旧首部节点相同"><a href="#4-7-2-VNode之新尾部节点和旧首部节点相同" class="headerlink" title="4.7.2 VNode之新尾部节点和旧首部节点相同"></a>4.7.2 <strong>VNode之新尾部节点和旧首部节点相同</strong></h5><p><img src="/assets/vue/diff_2.png" alt=""></p><h5 id="4-7-3-VNode之旧尾部节点和新首部节点相同"><a href="#4-7-3-VNode之旧尾部节点和新首部节点相同" class="headerlink" title="4.7.3 VNode之旧尾部节点和新首部节点相同"></a>4.7.3 <strong>VNode之旧尾部节点和新首部节点相同</strong></h5><p><img src="/assets/vue/diff_3.png" alt=""></p><h5 id="4-7-4-VNode之首部节点和旧除开首尾的节点vnodeToMove相同"><a href="#4-7-4-VNode之首部节点和旧除开首尾的节点vnodeToMove相同" class="headerlink" title="4.7.4 VNode之首部节点和旧除开首尾的节点vnodeToMove相同"></a>4.7.4 <strong>VNode之首部节点和旧除开首尾的节点vnodeToMove相同</strong></h5><p><img src="/assets/vue/diff_4.png" alt=""></p><h5 id="4-7-5-VNode之老数组先结束则批量添加"><a href="#4-7-5-VNode之老数组先结束则批量添加" class="headerlink" title="4.7.5 VNode之老数组先结束则批量添加"></a>4.7.5 <strong>VNode之老数组先结束则批量添加</strong></h5><p><img src="/assets/vue/diff_5.png" alt=""></p><h5 id="4-7-6-VNode之新数组先结束，批量删除"><a href="#4-7-6-VNode之新数组先结束，批量删除" class="headerlink" title="4.7.6 VNode之新数组先结束，批量删除"></a>4.7.6 <strong>VNode之新数组先结束，批量删除</strong></h5><p><img src="/assets/vue/diff_6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言-vue版本基于2-6-11&quot;&gt;&lt;a href=&quot;#前言-vue版本基于2-6-11&quot; class=&quot;headerlink&quot; title=&quot;前言(vue版本基于2.6.11)&quot;&gt;&lt;/a&gt;前言(vue版本基于2.6.11)&lt;/h3&gt;&lt;p&gt;学习一门框架的最好方式就
      
    
    </summary>
    
    
      <category term="vue" scheme="http://bozaigao.github.io/categories/vue/"/>
    
      <category term="源码" scheme="http://bozaigao.github.io/categories/vue/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://bozaigao.github.io/tags/vue/"/>
    
      <category term="源码" scheme="http://bozaigao.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>vue组件化实践</title>
    <link href="http://bozaigao.github.io/2020/07/04/vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://bozaigao.github.io/2020/07/04/vue组件化实践/</id>
    <published>2020-07-04T09:12:58.000Z</published>
    <updated>2020-07-16T09:06:06.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 当今流行的主流前端框架基本都有组件化开发思想，这样做的好处：便于<strong>多人开发</strong>、<strong>组件复用</strong>提高了<strong>开发效率</strong>、简化了<strong>调试步骤</strong>、提高了组件的<strong>可维护性</strong>，下面演示组件开发实践中的组件之间的通信方式，下面演示了vue组件之间通信的方式。</p><h3 id="1-父传子组件属性-Props"><a href="#1-父传子组件属性-Props" class="headerlink" title="1. 父传子组件属性(Props)"></a>1. 父传子组件属性(Props)</h3><figure class="highlight html"><figcaption><span>app.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">title</span>=<span class="string">"父传子"</span> @<span class="attr">getMsg</span>=<span class="string">"getFromChild"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>Child.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"sendMsgToParent"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-事件总线event"><a href="#2-事件总线event" class="headerlink" title="2. 事件总线event"></a>2. 事件总线event</h3><h4 id="2-1-子传父-通过emit触发子组件函数回调"><a href="#2-1-子传父-通过emit触发子组件函数回调" class="headerlink" title="2.1 子传父(通过emit触发子组件函数回调)"></a>2.1 子传父(通过emit触发子组件函数回调)</h4><figure class="highlight html"><figcaption><span>app.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">title</span>=<span class="string">"父传子"</span> @<span class="attr">getMsg</span>=<span class="string">"getFromChild"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>app.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  provide:&#123;</span><br><span class="line">    parentInitData:<span class="string">'从父组件初始化的数据'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getFromChild(msg) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>Child.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"sendMsgToParent"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Child.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'title'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">     sendMsgToParent() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'getMsg'</span>, <span class="string">'子传父'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-兄弟组件之间通信"><a href="#2-2-兄弟组件之间通信" class="headerlink" title="2.2 兄弟组件之间通信"></a>2.2 兄弟组件之间通信</h4><p>类似与EventBus，Vue实例已经实现了$on和$emit方法，只需需要在vue实例里面this.$on和this.$emit调用即可</p><figure class="highlight html"><figcaption><span>SiblingChild1.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"sendMsgToParent"</span>&gt;</span>SiblingChild1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight js"><figcaption><span>SiblingChild1.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsgToParent() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$parent.$emit(<span class="string">"parantEvent"</span>, <span class="string">"SiblingChild1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈"</span>, <span class="keyword">this</span>.$store);</span><br><span class="line">    <span class="keyword">this</span>.$parent.$on(<span class="string">"parantEvent"</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg !== <span class="string">"SiblingChild1"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"来自siblingChild2的消息"</span>, msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight html"><figcaption><span>SiblingChild2.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"sendMsgToParent"</span>&gt;</span>SiblingChild2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight js"><figcaption><span>SiblingChild2.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsgToParent() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$parent.$emit(<span class="string">"parantEvent"</span>, <span class="string">"SiblingChild2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$parent.$on(<span class="string">"parantEvent"</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg !== <span class="string">"SiblingChild2"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"来自siblingChild1的消息"</span>, msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里是通过兄弟组件共同的父亲组件<strong>this.$parent</strong>进行通信，相同的实例才能进行event事件通信</p></blockquote><h4 id="2-3-Vue原型链挂载dispatch和boardcast进行通信"><a href="#2-3-Vue原型链挂载dispatch和boardcast进行通信" class="headerlink" title="2.3 Vue原型链挂载dispatch和boardcast进行通信"></a>2.3 Vue原型链挂载dispatch和boardcast进行通信</h4> <figure class="highlight js"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> Vue.prototype.$dispatch = <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      parent.$emit(event, data)</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$boardcast = <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</span><br><span class="line">  boardcast.call(<span class="keyword">this</span>.event, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boardcast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    child.$emit(event, data)</span><br><span class="line">    <span class="keyword">if</span> (child.$children.length) &#123;</span><br><span class="line">      boardcast.call(child, event, data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现上面兄弟组件通信的另外一种方式,通过向父亲dispatch和子组件boardcast广播，这样在其他任何组件都可以收到该事件，只需要做相应的$on监听即可</p><figure class="highlight js"><figcaption><span>SiblingChild1.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsgToParent() &#123;</span><br><span class="line">      <span class="comment">// this.$parent.$emit("parantEvent", "SiblingChild1");</span></span><br><span class="line">      <span class="keyword">this</span>.$dispatch(<span class="string">"parantEvent"</span>, <span class="string">"SiblingChild1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈"</span>, <span class="keyword">this</span>.$store);</span><br><span class="line">    <span class="keyword">this</span>.$parent.$on(<span class="string">"parantEvent"</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg !== <span class="string">"SiblingChild1"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"来自siblingChild2的消息"</span>, msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>SiblingChild2.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsgToParent() &#123;</span><br><span class="line">      <span class="comment">// this.$parent.$emit("parantEvent", "SiblingChild2");</span></span><br><span class="line">      <span class="keyword">this</span>.$dispatch(<span class="string">"parantEvent"</span>, <span class="string">"SiblingChild2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$parent.$on(<span class="string">"parantEvent"</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg !== <span class="string">"SiblingChild2"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"来自siblingChild1的消息"</span>, msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-祖孙数据传递-provide-inject"><a href="#3-祖孙数据传递-provide-inject" class="headerlink" title="3. 祖孙数据传递(provide/inject)"></a>3. 祖孙数据传递(provide/inject)</h3><figure class="highlight js"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  provide:&#123;</span><br><span class="line">    parentInitData:<span class="string">'从父组件初始化的数据'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">    HelloWorld,</span><br><span class="line">    SiblingChild1,</span><br><span class="line">    SiblingChild2,</span><br><span class="line">    Parent,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getFromChild(msg) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>GrandSon.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;parentInitDataAlias&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  inject: &#123;</span><br><span class="line">    parentInitDataAlias: &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">from</span>: <span class="string">"parentInitData"</span>,</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">default</span>: <span class="string">""</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-最佳实践vuex"><a href="#3-最佳实践vuex" class="headerlink" title="3. 最佳实践vuex"></a>3. 最佳实践vuex</h3><figure class="highlight js"><figcaption><span>store.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        msg: <span class="string">'默认消息'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        updateMsg(state, msg = <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行了mutations'</span>)</span><br><span class="line">            state.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        updateMsg(msg = <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行了actions'</span>)</span><br><span class="line">            state.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>SiblingChild1.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"$store.commit('updateMsg')"</span>&gt;</span>&#123;&#123;$store.state.msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>SiblingChild2.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"$store.dispatch('updateMsg')"</span>&gt;</span>&#123;&#123;$store.state.msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终程序效果<br> <img src="/assets/vue/vue_01.jpg" alt=""></p><blockquote><p>自动导包和代码高亮vscode插件vetur,仓库地址：<a href="https://github.com/bozaigao/vue01" target="_blank" rel="noopener">https://github.com/bozaigao/vue01</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 当今流行的主流前端框架基本都有组件化开发思想，这样做的好处：便于&lt;strong&gt;多人开发&lt;/strong&gt;、&lt;strong&gt;组件复用&lt;/s
      
    
    </summary>
    
    
      <category term="vue" scheme="http://bozaigao.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://bozaigao.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>基于网易云信sdk的Flutter聊天脚手架</title>
    <link href="http://bozaigao.github.io/2020/04/25/%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1sdk%E7%9A%84Flutter%E8%81%8A%E5%A4%A9%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://bozaigao.github.io/2020/04/25/基于网易云信sdk的Flutter聊天脚手架/</id>
    <published>2020-04-25T08:26:11.000Z</published>
    <updated>2020-07-04T09:08:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flutter-server-client"><a href="#flutter-server-client" class="headerlink" title="flutter_server_client"></a>flutter_server_client</h1><p>基于网易云信sdk的Flutter聊天脚手架,主要对网易云信在Androidf和iOS原生端的聊天api进行了封装，对Android和iOS消息体的不同差异在Flutter端进行了抹平操作，<br>实现了登录、获取最近聊天会话、会话监听、聊天消息监听、onKick被踢单点登录监听，普通文本、emoji、图片、语音的发送和接受、自定义消息的解析和展示、以及历史聊天记录获取等功能，<br>只需简单在iOS端和Flutter端配置一下appkey就可直接账号登录查看，是一个开箱即用的Flutter聊天脚手架；</p><h3 id="key修改地方"><a href="#key修改地方" class="headerlink" title="key修改地方"></a>key修改地方</h3><p><img src="/assets/iOS_key.png" alt="iOS"><br><img src="/assets/flutter_key.png" alt="Flutter"></p><h3 id="iOS效果图"><a href="#iOS效果图" class="headerlink" title="iOS效果图"></a>iOS效果图</h3><p><img src="/assets/login_iOS.png" alt="iOS"><br><img src="/assets/session_iOS.png" alt="iOS"><br><img src="/assets/emoji_iOS.png" alt="iOS"><br><img src="/assets/choosepic_iOS.png" alt="iOS"></p><h3 id="Android效果图"><a href="#Android效果图" class="headerlink" title="Android效果图"></a>Android效果图</h3><p><img src="/assets/login_Android.png" alt="Android"><br><img src="/assets/session_Android.png" alt="Android"><br><img src="/assets/emoji_Android.png" alt="Android"><br><img src="/assets/choosepic_Android.png" alt="Android"></p><blockquote><p>项目地址<a href="https://github.com/bozaigao/flutter_server_client" target="_blank" rel="noopener">flutter_server_client</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flutter-server-client&quot;&gt;&lt;a href=&quot;#flutter-server-client&quot; class=&quot;headerlink&quot; title=&quot;flutter_server_client&quot;&gt;&lt;/a&gt;flutter_server_client&lt;/
      
    
    </summary>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/categories/Flutter/"/>
    
      <category term="NimSDK" scheme="http://bozaigao.github.io/categories/Flutter/NimSDK/"/>
    
      <category term="Android" scheme="http://bozaigao.github.io/categories/Flutter/NimSDK/Android/"/>
    
      <category term="iOS" scheme="http://bozaigao.github.io/categories/Flutter/NimSDK/Android/iOS/"/>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/tags/Flutter/"/>
    
      <category term="网易云信" scheme="http://bozaigao.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1/"/>
    
      <category term="聊天" scheme="http://bozaigao.github.io/tags/%E8%81%8A%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>fish-redux-demo基于fish-redux的Flutter脚手架</title>
    <link href="http://bozaigao.github.io/2020/01/28/fish-redux-demo%E5%9F%BA%E4%BA%8Efish-redux%E7%9A%84Flutter%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://bozaigao.github.io/2020/01/28/fish-redux-demo基于fish-redux的Flutter脚手架/</id>
    <published>2020-01-28T14:11:37.000Z</published>
    <updated>2020-04-29T01:29:03.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fish-redux-demo"><a href="#fish-redux-demo" class="headerlink" title="fish-redux-demo"></a>fish-redux-demo</h1><p>一个基于fish-redux的Flutter脚手架，包含基本的屏幕适配、全局toast提示、网络请求封装、路由框架集成、网络图片缓存，实现了在fish-redux框架下fluro路由框架的集成、演示了Flutter和WebView的双向通信，实现了在fish-redux模式下的页面跳转传参以及实现AutomaticKeepAliveClientMixin，以及实现了父组件和子组件局部数据和页面之间全局数据共享逻辑，是一个开箱即用不可多得的Flutter项目脚手架。</p><h2 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h2><p><img src="/assets/flutter_1.png" alt=""><br><img src="/assets/flutter_2.png" alt=""><br><img src="/assets/flutter_3.png" alt=""><br><img src="/assets/flutter_4.png" alt=""></p><blockquote><p>项目地址<a href="https://github.com/bozaigao/fish-redux-demo" target="_blank" rel="noopener">fish-redux-demo</a></p></blockquote><blockquote><p>出于业务安全考虑，Android和iOS原生端的加密公钥已经被抹掉请直接下载<a href="https://github.com/bozaigao/fish-redux-demo/blob/master/app.apk" target="_blank" rel="noopener">Android release 安装包</a>进行体验，账号:11211110085 密码:123456<br>Taro适配rn、h5、微信小程序友情链接<a href="https://github.com/bozaigao/Taro-demo" target="_blank" rel="noopener">Taro-demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fish-redux-demo&quot;&gt;&lt;a href=&quot;#fish-redux-demo&quot; class=&quot;headerlink&quot; title=&quot;fish-redux-demo&quot;&gt;&lt;/a&gt;fish-redux-demo&lt;/h1&gt;&lt;p&gt;一个基于fish-redux的Flu
      
    
    </summary>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/categories/Flutter/"/>
    
      <category term="fish-redux" scheme="http://bozaigao.github.io/categories/Flutter/fish-redux/"/>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/tags/Flutter/"/>
    
      <category term="fish-redux" scheme="http://bozaigao.github.io/tags/fish-redux/"/>
    
      <category term="Android" scheme="http://bozaigao.github.io/tags/Android/"/>
    
      <category term="iOS" scheme="http://bozaigao.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践项目脚手架</title>
    <link href="http://bozaigao.github.io/2019/12/30/github%E4%B8%8A%E8%83%BD%E6%89%BE%E5%88%B0%E7%9A%84taro%E9%80%82%E9%85%8DAndroid%E3%80%81iOS%E3%80%81%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%81H5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://bozaigao.github.io/2019/12/30/github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践项目脚手架/</id>
    <published>2019-12-30T03:55:17.000Z</published>
    <updated>2020-07-12T01:22:55.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Taro-demo"><a href="#Taro-demo" class="headerlink" title="Taro-demo"></a>Taro-demo</h1><p>github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践,主要涉及到了基础网络请求的封装、适配了多端的SafeArea安全区域、style工具样式引用替换scss的繁琐写法大幅度简化代码,同时解决了scss样式无法通过className进行属性传递的问题、自定义tabBar、全局模态对话框展示(解决了微信小程序端不能覆盖底部tabBar的问题)、展示了相同组件多端适配引用的方式、多端样式布局通过styleAssign注入flex、column、relative的方式实现统一化、演示了app的消息通信,通过mock数据在本地搭建服务进行前后端分离开发、本脚手架各端适配的比较完美适合用来进行全新项目的多端开发,后续基础组件持续完善中,目标是打造一个多端共用的基础组件库.</p><h3 id="适配进度"><a href="#适配进度" class="headerlink" title="适配进度"></a>适配进度</h3><ul><li><input checked="" disabled="" type="checkbox"> H5 – 完美适配</li><li><input checked="" disabled="" type="checkbox"> React Native – 完美适配</li><li><input checked="" disabled="" type="checkbox"> 微信小程序 – 完美适配</li></ul><h3 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h3><ul><li><input disabled="" type="checkbox"> 打造一个多端共用的基础组件库 – 持续开发完善中</li></ul><h3 id="样式转化"><a href="#样式转化" class="headerlink" title="样式转化"></a>样式转化</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home__search__top</span> &#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line"> <span class="attribute">flex-direction</span>: row;</span><br><span class="line"> <span class="attribute">align-items</span>: center;</span><br><span class="line"> <span class="attribute">background</span>: white;</span><br><span class="line"> <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述scss写法替换为以下写法,简化布局代码,同时解决了scss样式无法通过className进行属性传递的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;styleAssign([styles.udr,styles.uac,bgColor(<span class="string">'white'</span>),ml(<span class="number">20</span>),mr(<span class="number">20</span>)]&#125;</span><br></pre></td></tr></table></figure><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>typescript+eslint+redux+taro+react-native+mock</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>直接clone本项目进入项目根目录执行npm install操作,然后将third_changes对应目录里面的修改项替换项目根目录node_modules里面对应的组件,react-native原生端壳子<a href="https://github.com/bozaigao/Taro-demo-rn-shell" target="_blank" rel="noopener">Taro-demo-rn-shell</a>.<br>更多官方组件使用请移步<a href="https://taro-docs.jd.com" target="_blank" rel="noopener">京东Taro官方文档</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/qywx-dev.html" target="_blank" rel="noopener">微信小程序官方文档</a></p><ul><li>先打开本地mock服务命令:npm run mock</li><li>rn端运行命令:npm run dev:rm</li><li>h5端运行命令:npm run dev:h5</li><li>微信小程序端运行命令:npm run dev:weapp</li></ul><h3 id="多端适配效果图"><a href="#多端适配效果图" class="headerlink" title="多端适配效果图"></a>多端适配效果图</h3><p><img src="/assets/taro_1.jpeg" alt="效果图1"></p><p><img src="/assets/taro_2.jpeg" alt="效果图1"></p><p><img src="/assets/taro_3.jpeg" alt="效果图1"></p><p><img src="/assets/taro_4.jpeg" alt="效果图1"></p><blockquote><p>项目地址:<a href="https://github.com/bozaigao/Taro-demo" target="_blank" rel="noopener">https://github.com/bozaigao/Taro-demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Taro-demo&quot;&gt;&lt;a href=&quot;#Taro-demo&quot; class=&quot;headerlink&quot; title=&quot;Taro-demo&quot;&gt;&lt;/a&gt;Taro-demo&lt;/h1&gt;&lt;p&gt;github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践,
      
    
    </summary>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/categories/react-native/"/>
    
      <category term="大前端" scheme="http://bozaigao.github.io/categories/react-native/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Taro" scheme="http://bozaigao.github.io/categories/react-native/%E5%A4%A7%E5%89%8D%E7%AB%AF/Taro/"/>
    
      <category term="微信小程序" scheme="http://bozaigao.github.io/categories/react-native/%E5%A4%A7%E5%89%8D%E7%AB%AF/Taro/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="H5" scheme="http://bozaigao.github.io/categories/react-native/%E5%A4%A7%E5%89%8D%E7%AB%AF/Taro/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/H5/"/>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/tags/react-native/"/>
    
      <category term="大前端" scheme="http://bozaigao.github.io/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Taro" scheme="http://bozaigao.github.io/tags/Taro/"/>
    
      <category term="微信小程序" scheme="http://bozaigao.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="H5" scheme="http://bozaigao.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>解决Flutter项目运行报library not found for -libstdc++.6.0.9问题</title>
    <link href="http://bozaigao.github.io/2019/12/30/%E8%A7%A3%E5%86%B3Flutter%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%8A%A5library-not-found-for-libstdc-6-0-9%E9%97%AE%E9%A2%98/"/>
    <id>http://bozaigao.github.io/2019/12/30/解决Flutter项目运行报library-not-found-for-libstdc-6-0-9问题/</id>
    <published>2019-12-30T03:39:22.000Z</published>
    <updated>2019-12-30T03:49:11.812Z</updated>
    
    <content type="html"><![CDATA[<p>在运行Flutter项目的时候由于里面第三方库引用了libstdc++.6.0.9这个库文件而导致项目运行报错问题，苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之，<br>苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</p><blockquote><p>临时解决方法:将-libstdc++.6.0.9库文件导入xcode库文件，两个位置，一套是模拟器的，一套是设备的<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.0.sdk/usr/lib/<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/<br>-libstdc++.6.0.9下载地址:<a href="https://www.bozaigao.net/assets/libstdc++.6.0.9.tbd" target="_blank" rel="noopener">https://www.bozaigao.net/assets/libstdc++.6.0.9.tbd</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在运行Flutter项目的时候由于里面第三方库引用了libstdc++.6.0.9这个库文件而导致项目运行报错问题，苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之，&lt;br&gt;苹果的解释是libstdc++已经标记为废弃有5年了，
      
    
    </summary>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://bozaigao.github.io/tags/Flutter/"/>
    
      <category term="libstdc++.6.0.9" scheme="http://bozaigao.github.io/tags/libstdc-6-0-9/"/>
    
  </entry>
  
  <entry>
    <title>react-native使用chrome调试WebView</title>
    <link href="http://bozaigao.github.io/2019/12/25/react-native%E4%BD%BF%E7%94%A8chrome%E8%B0%83%E8%AF%95WebView/"/>
    <id>http://bozaigao.github.io/2019/12/25/react-native使用chrome调试WebView/</id>
    <published>2019-12-25T00:31:29.000Z</published>
    <updated>2019-12-25T00:48:51.059Z</updated>
    
    <content type="html"><![CDATA[<h4 id="react-native使用chrome调试WebView"><a href="#react-native使用chrome调试WebView" class="headerlink" title="react-native使用chrome调试WebView"></a>react-native使用chrome调试WebView</h4><ul><li><p>如果使用的是google模拟器则直接在chrome浏览器输入:chrome://inspect直接进行调试，如果是Android真机则需要去chrome应用商店安装ADB Plugin插件；<br><img src="/assets/webview_debug1.png" alt=""><br><img src="/assets/webview_debug2.jpeg" alt=""><br><img src="/assets/webview_debug3.jpeg" alt=""><br><img src="/assets/webview_debug4.jpeg" alt=""><br><img src="/assets/webview_debug5.jpeg" alt=""><br><img src="/assets/webview_debug6.jpeg" alt=""></p><blockquote><p>chrome应用商店下载插件需要翻墙，搭建教程：<a href="http://bozaigao.github.io/2019/11/07/使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子/">http://bozaigao.github.io/2019/11/07/使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子/</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;react-native使用chrome调试WebView&quot;&gt;&lt;a href=&quot;#react-native使用chrome调试WebView&quot; class=&quot;headerlink&quot; title=&quot;react-native使用chrome调试WebView&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/tags/react-native/"/>
    
      <category term="性能优化" scheme="http://bozaigao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>react-native热更新服务搭建</title>
    <link href="http://bozaigao.github.io/2019/11/20/react-native%E7%83%AD%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://bozaigao.github.io/2019/11/20/react-native热更新服务搭建/</id>
    <published>2019-11-20T02:39:04.000Z</published>
    <updated>2019-11-20T08:03:49.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为了实现react-native项目的版本增量静默更新需求，需要使用热更新服务，之前用过微软的code-push更新服务，但是由于微软的Azure服务器是在国外，国内访问网速慢且不稳定，于是需要在公司阿里云的ECS上搭建自己的热更新服务.</p><h4 id="热更新服务下载与文件修改"><a href="#热更新服务下载与文件修改" class="headerlink" title="热更新服务下载与文件修改"></a>热更新服务下载与文件修改</h4><p> 下载地址:<a href="https://github.com/lisong/code-push-server" target="_blank" rel="noopener">https://github.com/lisong/code-push-server</a><br> 然后主要是修改config/config.js 文件里里面的热更新包储存路径和下载基地址,最后将代码通过能够过ftp或者scp命令上传到服务端.<br> <figure class="highlight js"><figcaption><span>config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> db: &#123;</span><br><span class="line">    username: process.env.RDS_USERNAME || <span class="string">"root"</span>,</span><br><span class="line">    password: process.env.RDS_PASSWORD || <span class="literal">null</span>,</span><br><span class="line">    database: process.env.DATA_BASE || <span class="string">"codepush"</span>,</span><br><span class="line">    host: process.env.RDS_HOST || <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    port: process.env.RDS_PORT || <span class="number">3306</span>,</span><br><span class="line">    dialect: <span class="string">"mysql"</span>,</span><br><span class="line">    logging: <span class="literal">false</span>,</span><br><span class="line">    operatorsAliases: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">local: &#123;</span><br><span class="line">    <span class="comment">// Binary files storage dir, Do not use tmpdir and it's public download dir.</span></span><br><span class="line">    storageDir: process.env.STORAGE_DIR || <span class="string">"/codepush"</span>,</span><br><span class="line">    <span class="comment">// Binary files download host address which Code Push Server listen to. the files storage in storageDir.</span></span><br><span class="line">    downloadUrl: process.env.LOCAL_DOWNLOAD_URL || <span class="string">"http://your_server_addrss:3000/download"</span>,</span><br><span class="line">    <span class="comment">// public static download spacename.</span></span><br><span class="line">    public: <span class="string">'/download'</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="服务端数据库配置"><a href="#服务端数据库配置" class="headerlink" title="服务端数据库配置"></a>服务端数据库配置</h4><p> 在服务器创建codepush数据库，然后use codepush选择数据库，执行source codepush-all.sql(在code-psuh-server sql目录下) 命令创建数据库表和字段.</p><h4 id="启动热更新服务"><a href="#启动热更新服务" class="headerlink" title="启动热更新服务"></a>启动热更新服务</h4><ul><li><p>先确保服务端安装好了node等环境，然后进入code-push-server目录执行npm install安装第三方依赖.</p></li><li><p>执行npm install -g forever安装forever插件，在项目目录执行 forever start ./bin/www来持久化热更新服务</p><blockquote><p>forever作为node服务的守护进程，可以自动重启node服务，保证服务稳定运行</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;为了实现react-native项目的版本增量静默更新需求，需要使用热更新服务，之前用过微软的code-push更新服务，但是由于微软的Az
      
    
    </summary>
    
    
      <category term="热更新" scheme="http://bozaigao.github.io/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="热更新" scheme="http://bozaigao.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="code-push-server" scheme="http://bozaigao.github.io/tags/code-push-server/"/>
    
  </entry>
  
  <entry>
    <title>使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子(Mac和iphone环境搭建)</title>
    <link href="http://bozaigao.github.io/2019/11/07/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E7%BB%93%E5%90%88Shadowsocks%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"/>
    <id>http://bozaigao.github.io/2019/11/07/使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子/</id>
    <published>2019-11-07T08:10:04.000Z</published>
    <updated>2020-07-21T01:55:07.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 之前一用过Netfits、EasySSR、VyprVPN等一些第三方付费服务翻墙软件，但是自从国内政府严打VPN后陆陆续续翻墙的一些服务出现连接慢、网络延迟高、甚至服务直接不可用等状态，但是作为一名搞it的经常翻看国外技术文章的码农来说怎么能没有一款趁手的科学上网工具呢，由于第三方服务经常因为政策原因而变得不稳定，于是决定自己搭建一个翻墙工具。</p><h3 id="1-服务器端配置"><a href="#1-服务器端配置" class="headerlink" title="1. 服务器端配置"></a>1. 服务器端配置</h3><h4 id="1-1-境外服务器或ECS-只要不在大陆就可以了，阿里云、腾讯云、aws等云服务商都提供此类服务，我自己购买的是阿里云香港的服务器"><a href="#1-1-境外服务器或ECS-只要不在大陆就可以了，阿里云、腾讯云、aws等云服务商都提供此类服务，我自己购买的是阿里云香港的服务器" class="headerlink" title="1.1 境外服务器或ECS(只要不在大陆就可以了，阿里云、腾讯云、aws等云服务商都提供此类服务，我自己购买的是阿里云香港的服务器)"></a>1.1 境外服务器或ECS(只要不在大陆就可以了，阿里云、腾讯云、aws等云服务商都提供此类服务，我自己购买的是阿里云香港的服务器)</h4><p> 如果服务器只是用来翻墙查下资料或者部署下个人博客的话选择最低配的，带宽选1M的足够使用。<br> <img src="/assets/Shadowsocks1.1.jpg" alt=""></p><h4 id="1-2-服务端安装python版本的Shadowsocks"><a href="#1-2-服务端安装python版本的Shadowsocks" class="headerlink" title="1.2 服务端安装python版本的Shadowsocks"></a>1.2 服务端安装python版本的Shadowsocks</h4><ul><li><p>先安装pip</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="string">"get-pip.py"</span></span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure></li><li><p>再通过pip安装Shadowsocks</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>创建Shadowsocks配置文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br><span class="line">vi shadowsocks.json</span><br></pre></td></tr></table></figure><p> 配置文件内容如下：<br> <figure class="highlight"><figcaption><span>shadowsocks.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "server":"0.0.0.0",      --服务器IP，直接用0.0.0.0</span><br><span class="line"> "server_port":8888,      --端口端口</span><br><span class="line"> "local_address": "127.0.0.1", --本地地址</span><br><span class="line"> "local_port":1080,       --本地端口</span><br><span class="line"> "password":"password",     --密码</span><br><span class="line"> "timeout":300,         --超时时间</span><br><span class="line"> "method":"aes-256-cfb",    --加密策略，有多重策略，具体自查</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  如果你想配置多个登录账号，可以进行如下配置：</p><figure class="highlight"><figcaption><span>shadowsocks.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"0.0.0.0",      --服务器IP，直接用0.0.0.0</span><br><span class="line">    "port_password":&#123;</span><br><span class="line">    "8381": "password1",</span><br><span class="line">    "8382": "password2",</span><br><span class="line">         "8383": "password3",</span><br><span class="line">        "8384": "password4"</span><br><span class="line">    &#125;,</span><br><span class="line">    "local_address": "127.0.0.1", --本地地址</span><br><span class="line">    "local_port":1080,       --本地端口</span><br><span class="line">    "timeout":300,         --超时时间</span><br><span class="line">    "method":"aes-256-cfb",    --加密策略，有多重策略，具体自查</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong>如果取成系统端口会导致服务启动失败<br>  <img src="/assets/port_busy.jpg" alt=""></p><blockquote><p>端口号一定不要随便取，如果取成了系统端口比如443会导致端口被占用从而导致服务启动失败</p></blockquote><h4 id="1-3-启动Shadowsocks服务"><a href="#1-3-启动Shadowsocks服务" class="headerlink" title="1.3 启动Shadowsocks服务"></a>1.3 启动Shadowsocks服务</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">ssserver -c /etc/shadowsocks.json -d restart</span><br></pre></td></tr></table></figure><blockquote><p>如果发现Shadowsocks客户端一直连不上请到/var/log/shadowsocks.log查看服务报错日志，根据报错信息解决问题.</p></blockquote><h4 id="1-4-阿里云配置服务器安全入网策略"><a href="#1-4-阿里云配置服务器安全入网策略" class="headerlink" title="1.4 阿里云配置服务器安全入网策略"></a>1.4 阿里云配置服务器安全入网策略</h4><p> <img src="/assets/ruwang_celue.jpg" alt=""></p><blockquote><p>出网策略不用配置，安全组出方向默认允许所有访问，即从安全组内ECS访问外部都是放行的。</p></blockquote><h3 id="2-本地电脑客户端配置"><a href="#2-本地电脑客户端配置" class="headerlink" title="2. 本地电脑客户端配置"></a>2. 本地电脑客户端配置</h3><h4 id="2-1-Shadowsocks客户端下载"><a href="#2-1-Shadowsocks客户端下载" class="headerlink" title="2.1 Shadowsocks客户端下载"></a>2.1 Shadowsocks客户端下载</h4><p> 下载地址：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases/</a><br> <img src="/assets/Shadowsocks.jpg" alt=""></p><h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><p>压缩文件中直接就是Mac的app程序，解压后移动到Mac程序目录即可；</p><h4 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h4><p> <img src="/assets/peizhi.jpeg" alt=""><br> <img src="/assets/peizhi2.jpg" alt=""></p><h3 id="3-翻墙效果"><a href="#3-翻墙效果" class="headerlink" title="3. 翻墙效果"></a>3. 翻墙效果</h3><p> <img src="/assets/enjoy.jpg" alt=""></p><blockquote><p>Shadowsocks有PAC模式和全局模式:<br>PAC模式：也就是智能分流模式，根据规则去匹配你访问的网站，国外网站走代理，国内网站不走代理；<br>全局模式：国内、国外所有网站都走代理；<br>我一般默认开PAC模式，这样加载国内网站速度会比较快，遇到网站加载很慢再开全局模式进行访问。<br><strong>注意</strong>：如果服务运行一段时间突然发现翻不了墙了，可能是阿里云那边做了限制，重新配置新的端口安全策略再重启Shadowsocks服务即可。</p></blockquote><h3 id="4-iphone安装Shadowrocket"><a href="#4-iphone安装Shadowrocket" class="headerlink" title="4. iphone安装Shadowrocket"></a>4. iphone安装Shadowrocket</h3><p>appstore中国区由于政策原因已经下架，直接登录美区账号搜索下载<br><strong>账号:<a href="mailto:4ssgit@Gmail.com" target="_blank" rel="noopener">4ssgit@Gmail.com</a>   密码:V2Server</strong><br>如果登录失败请参考以下链接:<a href="https://shadowsockshelp.github.io/Shadowsocks/appleid.html" target="_blank" rel="noopener">https://shadowsockshelp.github.io/Shadowsocks/appleid.html</a><br>进入Shadowrocket主界面后在首页点击添加服务器节点然后输入ip、端口号、加密方式和连接密码即可，配置以及登录twitter效果如下：<br><img src="/assets/Shadowrocket1.jpeg" alt="">  <img src="/assets/Shadowrocket2.png" alt="">  <img src="/assets/Shadowrocket3.png" alt=""></p><blockquote><p><strong>切记一定不要登录iCloud账号只需要登录appstore账号就可以了，不然手机被账号拥有者恶意锁定的话就无法解锁了。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 之前一用过Netfits、EasySSR、VyprVPN等一些第三方付费服务翻墙软件，但是自从国内政府严打VPN后陆陆续续翻墙的一些服务出
      
    
    </summary>
    
    
      <category term="翻墙" scheme="http://bozaigao.github.io/categories/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="工具" scheme="http://bozaigao.github.io/categories/%E7%BF%BB%E5%A2%99/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="VPN" scheme="http://bozaigao.github.io/categories/%E7%BF%BB%E5%A2%99/%E5%B7%A5%E5%85%B7/VPN/"/>
    
    
      <category term="Shadowsocks" scheme="http://bozaigao.github.io/tags/Shadowsocks/"/>
    
      <category term="VPN" scheme="http://bozaigao.github.io/tags/VPN/"/>
    
      <category term="翻墙" scheme="http://bozaigao.github.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>react-native版本升级</title>
    <link href="http://bozaigao.github.io/2019/09/07/react-native%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/"/>
    <id>http://bozaigao.github.io/2019/09/07/react-native版本升级/</id>
    <published>2019-09-07T01:57:33.000Z</published>
    <updated>2020-07-18T10:27:39.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-rn版本从0-51-0升级到0-60-4"><a href="#1-rn版本从0-51-0升级到0-60-4" class="headerlink" title="1. rn版本从0.51.0升级到0.60.4"></a>1. rn版本从0.51.0升级到0.60.4</h3><p>升级目的：rn从0.60.2引入了<strong>Hermes</strong> 新的js引擎，新的引擎从<code>字节码预编译</code>、<code>无JIT</code>、<code>新的垃圾回收策略</code>等优化了Android端apk大小，减少了内存使用，页面切换的帧率也比之前有了提高,本次分享的主题主要是解决在版本升级过程中遇到的问题。</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><p>项目备份,初始化0.64.0版本的对应项目,保证初始化新项目iOS pod install、android 在target=0.28.0 clean rebuild正常运行,确保环境版本没问题,有问题的话直接查询react-native issue保证项目纯净，能正常运行;</p><h3 id="3-js项目端升级"><a href="#3-js项目端升级" class="headerlink" title="3. js项目端升级"></a>3. js项目端升级</h3><p> 按照官方建议升级步骤,进入要升级的项目先执行react-native-git-upgare脚本自动升级命令,执行该命令会自动覆盖文件,一定记得要备份原项目,然后静静地等待升级完成,如果无法识别该命令,请先执行npm install react-native-git-upgare -g,<br>结果升级中途报错无奈只能改为手动升级;</p><p><img src="/assets/src_1.png" alt="js脚本升级报错"></p><blockquote><p>由于上述操作报错改为手动修改模式,将之前原项目src和package.json里面的依赖全部拷贝到新项目然后执行npm install先安装第三方依赖;</p></blockquote><h3 id="4-iOS原生端升级"><a href="#4-iOS原生端升级" class="headerlink" title="4. iOS原生端升级"></a>4. iOS原生端升级</h3><h4 id="4-1-拷贝iOS原生文件"><a href="#4-1-拷贝iOS原生文件" class="headerlink" title="4.1 拷贝iOS原生文件"></a>4.1 拷贝iOS原生文件</h4><p> 将iOS原生代码和Podfile依赖拷贝到对应位置,然后iOS执行pod install操作;此时有可能依赖的第三方组件会报一下错误:<br><img src="/assets/iOS_1.png" alt="iOS第三方组件依赖报错"></p><h4 id="4-2-修改并保存第三方库文件"><a href="#4-2-修改并保存第三方库文件" class="headerlink" title="4.2 修改并保存第三方库文件"></a>4.2 修改并保存第三方库文件</h4><p> 将iOS第三方包*.podspec里面的s.dependency ‘React/Core’修改为 s.dependency ‘React-Core’然后再重新执行pod install,记得修改后的第三方内容需要单独拷贝出来不然每次执行npm install后都会被覆盖;</p><h4 id="4-3-解决iOS原生端报错"><a href="#4-3-解决iOS原生端报错" class="headerlink" title="4.3 解决iOS原生端报错"></a>4.3 解决iOS原生端报错</h4><p> 如果静待pod install执行完毕没问题后，运行项目可能还会报以下错误:<br><img src="/assets/iOS_2.png" alt="iOS第三方组件依赖报错"><br> 直接将node_modules/react/React里面的React.xcodeproj拖入Libraries即可,切记不要将libReact.a也添加到项目中,否则会和pod依赖的React有多个类重复报错;<br> 幸运的话项目应该可以直接跑起来了，但是跑起来后可能还会报以下运行报错:<br><img src="/assets/iOS_3.png" alt="iOS第三方组件依赖报错"></p><p> 进入项目目录执行</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-react-native@5.0.2</span><br></pre></td></tr></table></figure><h4 id="4-4-解决js运行报错"><a href="#4-4-解决js运行报错" class="headerlink" title="4.4 解决js运行报错"></a>4.4 解决js运行报错</h4><p> 解决了上一个问题还可能会报错:<br><img src="/assets/iOS_4.png" alt="iOS第三方组件依赖报错"></p><p> 在.babelrc文件添加以下代码</p><figure class="highlight javascript"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"presets"</span>: [<span class="string">"module:metro-react-native-babel-preset"</span>]&#125;</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start --reset-cache 或者 react-native start --reset-cache</span><br></pre></td></tr></table></figure><p> 最后模拟器运行不报错了但是真机运行却会崩溃，通过文件引用关系发现之前在js层封装了一个uuid的公共方法，但是rn0.60.4版本却会直接报错，关键是通过仅有的堆栈信息无法得知是uuid的问题，<br>通过修改uuid名字得到解决；<br><img src="/assets/iOS_5.png" alt="iOS第三方组件依赖报错"></p><h3 id="5-Android原生端升级"><a href="#5-Android原生端升级" class="headerlink" title="5. Android原生端升级"></a>5. Android原生端升级</h3><h4 id="5-1-拷贝Android原生文件"><a href="#5-1-拷贝Android原生文件" class="headerlink" title="5.1 拷贝Android原生文件"></a>5.1 拷贝Android原生文件</h4><p> 将Android原生代码和app目录下的build.gradle依赖拷贝到对应位置,然后执行sync操作,rn0.60.4依赖的api版本是28，所以可能需要把support包改成AndroidX的引用方式;</p><h4 id="5-2-解决Android端原生报错"><a href="#5-2-解决Android端原生报错" class="headerlink" title="5.2 解决Android端原生报错"></a>5.2 解决Android端原生报错</h4><p> 修改完后build可能会报以下错误：<br><img src="/assets/Android_1.png" alt="Android报错"><br>通过点击AndroidManifest.xml=&gt;Merged Manifest,查看error信息解决<br><img src="/assets/Android_2.png" alt="Android报错"></p><h3 id="6-Android原生端继续报错"><a href="#6-Android原生端继续报错" class="headerlink" title="6. Android原生端继续报错"></a>6. Android原生端继续报错</h3><p><img src="/assets/Android_3.png" alt="Android报错"><br>在app build.gradle我去掉了 annotationProcessor ‘com.github.bumptech.glide:compiler:4.2.0’</p><h3 id="7-升级后的效果"><a href="#7-升级后的效果" class="headerlink" title="7. 升级后的效果"></a>7. 升级后的效果</h3><p>android apk安装包比之前减少了4M左右，内存使用减少了30M左右，页面切换率提高了5～10帧/s<br><img src="/assets/Android_4.png" alt="Android报错"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-rn版本从0-51-0升级到0-60-4&quot;&gt;&lt;a href=&quot;#1-rn版本从0-51-0升级到0-60-4&quot; class=&quot;headerlink&quot; title=&quot;1. rn版本从0.51.0升级到0.60.4&quot;&gt;&lt;/a&gt;1. rn版本从0.51.0升级到0.
      
    
    </summary>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>react-native性能优化</title>
    <link href="http://bozaigao.github.io/2019/09/06/react-native%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://bozaigao.github.io/2019/09/06/react-native性能优化/</id>
    <published>2019-09-06T03:02:49.000Z</published>
    <updated>2020-07-18T15:42:53.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-native-log日志新能优化有两种方式"><a href="#react-native-log日志新能优化有两种方式" class="headerlink" title="react-native log日志新能优化有两种方式"></a>react-native log日志新能优化有两种方式</h3><p>第一种是使用babel-plugin-transform-remove-console插件在打包的时候自动去掉所有log信息，但是亲测在rn 0.51.0版本有效在0.60.3版本打包拆包后发现log信息并没有去掉，插件功能失效；<br>第二种则是采用官方的建议</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!__DEV__) &#123;</span><br><span class="line">  global.console = &#123;</span><br><span class="line">    info: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    log: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    warn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    debug: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    error: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实这是不准确的，因为在console里面可能还有其他方法比如console.clear、console.dir、console.profile等，如果在第三方组件里面有用到这些方法调用则会找不到该方法从而导致未知错误，正确的处理方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!__DEV__) &#123;</span><br><span class="line">            global.console.info = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            global.console.log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            global.console.warn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            global.console.debug = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            global.console.error = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;react-native-log日志新能优化有两种方式&quot;&gt;&lt;a href=&quot;#react-native-log日志新能优化有两种方式&quot; class=&quot;headerlink&quot; title=&quot;react-native log日志新能优化有两种方式&quot;&gt;&lt;/a&gt;react
      
    
    </summary>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://bozaigao.github.io/tags/react-native/"/>
    
      <category term="性能优化" scheme="http://bozaigao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
