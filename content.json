[{"title":"vue源码剖析","date":"2020-07-13T11:49:26.000Z","path":"2020/07/13/vue源码剖析/","text":"前言(vue版本基于2.6.11)学习一门框架的最好方式就是进行源码剖析，只有从源码角度去窥探vue的运行原理才能对vue的开发更加得心应手，对框架的运行机制才能更了然于心。 1.vue源码目录层级 2.调试环境搭建2.1 安装依赖1npm i 2.2 全局安装rollup js打包工具1npm i -g rollup 2.3 修改package.json打包脚本1\"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\" 这里增加了 –sourcemap配置，这样设置主要的目的是在后面调试的时候可以直接根据.js.map源码映射关系直接定位到源码文件在文件目录树中的位置，方便后面自己对应着进行源码位置查找与阅读。 2.4 打包生成js库1npm run dev 2.5 引用我们上面打包好的vue.js进行调试1&lt;script src=\"../../dist/vue.js\"&gt;&lt;/script&gt; 3.入口文件12345678'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125; 从script/config.js里面web-full-dev可以看出我们要打包的对应平台版本的入口文件是entry-runtime-with-compiler.js 4.vue初始化流程（下面将以源码的执行顺序为目录进行分析）4.1 思维导图 4.2 src/core/index.js在这个文件里面调用inintGlobalAPI方法来初始化全局api，比如set、delete、nextTick等，其中比较重要的是调用了initAssetRegisters这个函数，这个函数从src/core/global-api/assets.js文件里面导入，主要功能是遍历’component’、’directive’、’filter’生成全局注册方法并挂载到Vue.options上面，以’component’为例，通过this.options._base.extend(definition)调用生成组件的构造函数并在options进行挂载，例如我们在全局申明如下的组件就会生成类似于this.options = {components:{‘comp’:comp构造函数}}这样的数据，后面在调用createElement生成元素虚拟节点的时候就会根据全局的options里面的组件id获取到组件的构造函数进而使用这个构造函数传入createComponent生成最终的component VNode。 123Vue.component('comp', &#123; template: '&lt;div&gt;I am comp&lt;/div&gt;' &#125;) 4.3 src/core/instance/init.js组件初始化会调用_init函数，在这个函数里面依次调用了下面函数：initLifecycle这里面主要是对$parent/$root/$children进行了一系列初始化initEvents事件监听initRendercreateElement方法进行挂载vm.$createElement和vm._ccallHook(vm, ‘beforeCreate’)组件创建之前钩子调用initInjections注入祖辈传递的数据initState(重要)这里面最重要的功能是实现数据的响应式，调用后会生成Observer实例，而Observer实例是在src/core/observer/index.js文件里面进行的定义，这里面针对对象数据的传入会遍历key值然后挨个调用defineReactive observer.js123456789101112131415161718192021222324252627282930313233343536373839404142Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 依赖收集 if (Dep.target) &#123; // dep n:n watcher // 组件内会有很多key，所以一个watcher会有多个dep dep.depend() // 如果存在子ob：主要用于未来对象可能有属性增删，数组会有元素增删 if (childOb) &#123; // 对象内部小管家要和当前watcher建立关系 childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;) 在这个函数内部最终会调用js的原生函数Object.defineProperty来实现数据的响应式,在这里面重写了get和set两个方法，当数据一开始被设置的时候调用get方法在里面调用addDep完成Dep大管家和Watcher的绑定关系，如果对象data里面的value值也是一个对象则完成小管家dep和Watcher的绑定关系，最终在数据通过set方法进行变更的时候调用里面的dep.notify Watcher将执行更新操作,然后将执行quequeqWatcher=&gt;flashSchedulerQueque最终实现异步更新操作，具体流程见下面思维导图：initProvide处理祖辈传入的数据和属性callHook(vm, ‘created’)创建成功钩子回调 4.4 src/platforms/web/entry-runtime-with-compiler.js这个文件里面主要在Vue的prototype上面挂载了$mount的全局方法，在这个函数里面最重要的功能是返回了render渲染函数： entry-runtime-with-compiler.js中关键代码1234567const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) 所谓渲染函数指的是vue文件里面的template模板经过parse解析为AST抽象语法树以及generate生成code string后经过new Function包裹一层后可以执行的函数，如下： 1234ƒ anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('h1',[_v(\"Vue组件化机制\")]),_v(\" \"),_c('comp')],1)&#125;&#125; 同时在函数的末尾调用了$mount方法，而$mount方法其实最开始是定义在src/platforms/web/runtime/index.js里面，这个函数里面调用了src/core/instance/lifecycle.js里面的mountComponent方法,整个流程就是获取了render渲染函数后就开始调用mountComponent这个方法，而在mountComponent方法里面则通过Watcher调用了_render,_render函数是在src/core/instance/render.js中定义的，这里面主要的作用是将crateElement作为参数传入后执行options中的render渲染函数，渲染函数中的_c方法在render.js中有定义其实就是传入的createElment方法 render.js1vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 其他符号如_v等在src/core/instance/render-helpers/index.js文件里面可以找到对应的函数，最终执行的渲染函数实际上就是如下形式： 1234ƒ anonymous() &#123;with(this)&#123;return createElement('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[createElement('h1',[createTextVNode(\"Vue组件化机制\")]),createTextVNode(\" \"),createElement('comp')],1)&#125;&#125; 当执行$mount方法的时候src/core/instance/lifecycle.js里面的mountComponent会被执行，然后这里面的updateComponent方法里面的render渲染函数将会被Watcher触发，然后就会调用src/core/vdom/create-element.js里面的createElement函数进行虚拟节点VNode的创建。 4.5 src/core/vdom/create-element.js这里面会根据传入的到底是系统保留标签还是自定义组件进行分别处理，如果是系统保留标签则生成系统标签对应的VNode，如果是自定义组件则会调用src/core/vdom/create-component.js里面的createComponent函数。 4.6 src/core/vdom/create-component.js这个方法里面会要求传入一个自定义组件的Ctor构造函数，这个函数是在createElment里面通过resolveAsset方法传入，以Comp组件为例，则是以this.$options.components.Comp的形式获取到组件的构造函数，组件的构造函数在$options的挂载在以上4.2节inintGlobalAPI的时候有说明，至此将生成组件的VNode予以返回，当然在这里还有一个重要的伏笔那就是在返回虚拟节点之前还调用了installComponentHooks这个函数，在data里面安装了组件生命周期的函数钩子componentVNodeHooks，里面包含init、prepatch、insert、destroy，其中最重要的是init函数，这在后面执行patch实例化组件的时候将会调用这个初始化钩子，render函数最终生成VNode后将会执行src/core/instance/lifecycle.js里面的_update函数，最终调用src/core/vdom/patch.js里面的patch函数进行diff打补丁更新操作。 4.7 src/core/vdom/patch.js在patch里面将会传入虚拟节点调用createElm方法，这里也会根据元素的类型进行分别处理，如果是系统保留标签则直接初始化并插入父元素，如果是组件则会调用createComponent方法，在方法里面会根据4.6中安装的组件生命周期函数钩子函数的init方法来初始化组件，注意这里的createComponent和4.6中的createComponent不一样，虽然方法同名但是功能不同，一个是生成VNode一个是实例化组件，在componentVNodeHooks的init里面又调用了child.$mount方法，于是将重复4.3步骤直到递归没有子组件为止,具体流程见最开始的vue初始化思维导图,如果是首次更新那么直接会实例化组件，并进行挂载除开首次更新外组件补丁的过程其实就是执行patchVnode首尾双循环的一个比较过程： patch.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 循环条件：开始游标只要超过结束游标 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 游标位置调整 if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // 首尾判断开始 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 首尾都没找到相同的，从新数组头一个拿出来，去老数组中寻找相同的 if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element // 没找到，创建追加 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; // 找到了，对两者打补丁 vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined // 同时要做移动操作 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; 4.7.1 VNode之首尾相同 4.7.2 VNode之新尾部节点和旧首部节点相同 4.7.3 VNode之旧尾部节点和新首部节点相同 4.7.4 VNode之首部节点和旧除开首尾的节点vnodeToMove相同 4.7.5 VNode之老数组先结束则批量添加 4.7.6 VNode之新数组先结束，批量删除","tags":[{"name":"vue","slug":"vue","permalink":"http://bozaigao.github.io/tags/vue/"},{"name":"源码'","slug":"源码","permalink":"http://bozaigao.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"vue组件化实践","date":"2020-07-04T09:12:58.000Z","path":"2020/07/04/vue组件化实践/","text":"前言 当今流行的主流前端框架基本都有组件化开发思想，这样做的好处：便于多人开发、组件复用提高了开发效率、简化了调试步骤、提高了组件的可维护性，下面演示组件开发实践中的组件之间的通信方式，下面演示了vue组件之间通信的方式。 1. 父传子组件属性(Props)app.vue1&lt;Child title=\"父传子\" @getMsg=\"getFromChild\" /&gt; Child.vue1&lt;div @click=\"sendMsgToParent\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; 2. 事件总线event2.1 子传父(通过emit触发子组件函数回调)app.vue1&lt;Child title=\"父传子\" @getMsg=\"getFromChild\" /&gt; app.vue1234567891011121314export default &#123; name: 'App', provide:&#123; parentInitData:'从父组件初始化的数据' &#125;, components: &#123; Child, &#125;, methods: &#123; getFromChild(msg) &#123; console.log(msg) &#125; &#125;&#125; Child.vue1&lt;div @click=\"sendMsgToParent\"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; Child.vue12345678export default &#123; props: ['title'], methods: &#123; sendMsgToParent() &#123; this.$emit('getMsg', '子传父') &#125; &#125;&#125; 2.2 兄弟组件之间通信类似与EventBus，Vue实例已经实现了$on和$emit方法，只需需要在vue实例里面this.$on和this.$emit调用即可 SiblingChild1.vue1&lt;p @click=\"sendMsgToParent\"&gt;SiblingChild1&lt;/p&gt; SiblingChild1.vue123456789101112131415 export default &#123; methods: &#123; sendMsgToParent() &#123; this.$parent.$emit(\"parantEvent\", \"SiblingChild1\"); &#125; &#125;, mounted() &#123; console.log(\"哈\", this.$store); this.$parent.$on(\"parantEvent\", msg =&gt; &#123; if (msg !== \"SiblingChild1\") &#123; console.log(\"来自siblingChild2的消息\", msg); &#125; &#125;); &#125;&#125; SiblingChild2.vue1&lt;p @click=\"sendMsgToParent\"&gt;SiblingChild2&lt;/p&gt; SiblingChild2.vue1234567891011121314 export default &#123; methods: &#123; sendMsgToParent() &#123; this.$parent.$emit(\"parantEvent\", \"SiblingChild2\"); &#125; &#125;, mounted() &#123; this.$parent.$on(\"parantEvent\", msg =&gt; &#123; if (msg !== \"SiblingChild2\") &#123; console.log(\"来自siblingChild1的消息\", msg); &#125; &#125;); &#125;&#125; 注意这里是通过兄弟组件共同的父亲组件this.$parent进行通信，相同的实例才能进行event事件通信 2.3 Vue原型链挂载dispatch和boardcast进行通信 App.vue123456789101112131415161718192021222324 Vue.prototype.$dispatch = function (event, data) &#123; let parent = this.$parent; while (parent) &#123; if (parent) &#123; parent.$emit(event, data) parent = parent.$parent &#125; else &#123; break; &#125; &#125;&#125;Vue.prototype.$boardcast = function (event, data) &#123; boardcast.call(this.event, data)&#125;function boardcast() &#123; this.$children.forEach(child =&gt; &#123; child.$emit(event, data) if (child.$children.length) &#123; boardcast.call(child, event, data) &#125; &#125;)&#125; 然后实现上面兄弟组件通信的另外一种方式,通过向父亲dispatch和子组件boardcast广播，这样在其他任何组件都可以收到该事件，只需要做相应的$on监听即可 SiblingChild1.vue12345678910111213141516export default &#123; methods: &#123; sendMsgToParent() &#123; // this.$parent.$emit(\"parantEvent\", \"SiblingChild1\"); this.$dispatch(\"parantEvent\", \"SiblingChild1\"); &#125; &#125;, mounted() &#123; console.log(\"哈\", this.$store); this.$parent.$on(\"parantEvent\", msg =&gt; &#123; if (msg !== \"SiblingChild1\") &#123; console.log(\"来自siblingChild2的消息\", msg); &#125; &#125;); &#125;&#125;; SiblingChild2.vue123456789101112131415export default &#123; methods: &#123; sendMsgToParent() &#123; // this.$parent.$emit(\"parantEvent\", \"SiblingChild2\"); this.$dispatch(\"parantEvent\", \"SiblingChild2\"); &#125; &#125;, mounted() &#123; this.$parent.$on(\"parantEvent\", msg =&gt; &#123; if (msg !== \"SiblingChild2\") &#123; console.log(\"来自siblingChild1的消息\", msg); &#125; &#125;); &#125;&#125;; 3. 祖孙数据传递(provide/inject)App.vue123456789101112131415161718export default &#123; name: 'App', provide:&#123; parentInitData:'从父组件初始化的数据' &#125;, components: &#123; Child, HelloWorld, SiblingChild1, SiblingChild2, Parent, &#125;, methods: &#123; getFromChild(msg) &#123; console.log(msg) &#125; &#125;&#125; GrandSon.vue12345678910111213&lt;template&gt; &lt;p&gt;&#123;&#123;parentInitDataAlias&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: &#123; parentInitDataAlias: &#123; from: \"parentInitData\", default: \"\" &#125; &#125;&#125;; 3. 最佳实践vuexstore.js1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; msg: '默认消息' &#125;, mutations: &#123; updateMsg(state, msg = '') &#123; console.log('执行了mutations') state.msg = msg; &#125; &#125;, actions: &#123; updateMsg(msg = '') &#123; console.log('执行了actions') state.msg = msg; &#125; &#125;&#125;) App.vue123456new Vue(&#123; store, el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) SiblingChild1.vue1&lt;p @click=\"$store.commit('updateMsg')\"&gt;&#123;&#123;$store.state.msg&#125;&#125;&lt;/p&gt; SiblingChild2.vue1&lt;p @click=\"$store.dispatch('updateMsg')\"&gt;&#123;&#123;$store.state.msg&#125;&#125;&lt;/p&gt; 最终程序效果 自动导包和代码高亮vscode插件vetur,仓库地址：https://github.com/bozaigao/vue01","tags":[{"name":"vue","slug":"vue","permalink":"http://bozaigao.github.io/tags/vue/"}]},{"title":"基于网易云信sdk的Flutter聊天脚手架","date":"2020-04-25T08:26:11.000Z","path":"2020/04/25/基于网易云信sdk的Flutter聊天脚手架/","text":"flutter_server_client基于网易云信sdk的Flutter聊天脚手架,主要对网易云信在Androidf和iOS原生端的聊天api进行了封装，对Android和iOS消息体的不同差异在Flutter端进行了抹平操作，实现了登录、获取最近聊天会话、会话监听、聊天消息监听、onKick被踢单点登录监听，普通文本、emoji、图片、语音的发送和接受、自定义消息的解析和展示、以及历史聊天记录获取等功能，只需简单在iOS端和Flutter端配置一下appkey就可直接账号登录查看，是一个开箱即用的Flutter聊天脚手架； key修改地方 iOS效果图 Android效果图 项目地址flutter_server_client","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://bozaigao.github.io/tags/Flutter/"},{"name":"网易云信","slug":"网易云信","permalink":"http://bozaigao.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91%E4%BF%A1/"},{"name":"聊天","slug":"聊天","permalink":"http://bozaigao.github.io/tags/%E8%81%8A%E5%A4%A9/"}]},{"title":"fish-redux-demo基于fish-redux的Flutter脚手架","date":"2020-01-28T14:11:37.000Z","path":"2020/01/28/fish-redux-demo基于fish-redux的Flutter脚手架/","text":"fish-redux-demo一个基于fish-redux的Flutter脚手架，包含基本的屏幕适配、全局toast提示、网络请求封装、路由框架集成、网络图片缓存，实现了在fish-redux框架下fluro路由框架的集成、演示了Flutter和WebView的双向通信，实现了在fish-redux模式下的页面跳转传参以及实现AutomaticKeepAliveClientMixin，以及实现了父组件和子组件局部数据和页面之间全局数据共享逻辑，是一个开箱即用不可多得的Flutter项目脚手架。 效果图如下 项目地址fish-redux-demo 出于业务安全考虑，Android和iOS原生端的加密公钥已经被抹掉请直接下载Android release 安装包进行体验，账号:11211110085 密码:123456Taro适配rn、h5、微信小程序友情链接Taro-demo","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://bozaigao.github.io/tags/Flutter/"},{"name":"fish-redux","slug":"fish-redux","permalink":"http://bozaigao.github.io/tags/fish-redux/"},{"name":"Android","slug":"Android","permalink":"http://bozaigao.github.io/tags/Android/"},{"name":"iOS","slug":"iOS","permalink":"http://bozaigao.github.io/tags/iOS/"}]},{"title":"github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践项目脚手架","date":"2019-12-30T03:55:17.000Z","path":"2019/12/30/github上能找到的taro适配Android、iOS、微信小程序、H5最佳实践项目脚手架/","text":"Taro-demogithub上能找到的taro适配Android、iOS、微信小程序、H5最佳实践,主要涉及到了基础网络请求的封装、适配了多端的SafeArea安全区域、style工具样式引用替换scss的繁琐写法大幅度简化代码,同时解决了scss样式无法通过className进行属性传递的问题、自定义tabBar、全局模态对话框展示(解决了微信小程序端不能覆盖底部tabBar的问题)、展示了相同组件多端适配引用的方式、多端样式布局通过styleAssign注入flex、column、relative的方式实现统一化、演示了app的消息通信,通过mock数据在本地搭建服务进行前后端分离开发、本脚手架各端适配的比较完美适合用来进行全新项目的多端开发,后续基础组件持续完善中,目标是打造一个多端共用的基础组件库. 适配进度 H5 – 完美适配 React Native – 完美适配 微信小程序 – 完美适配 目标功能 打造一个多端共用的基础组件库 – 持续开发完善中 样式转化12345678.home__search__top &#123; display: flex; flex-direction: row; align-items: center; background: white; margin-left: 20px; margin-right: 20px;&#125; 将上述scss写法替换为以下写法,简化布局代码,同时解决了scss样式无法通过className进行属性传递的问题 1style=&#123;styleAssign([styles.udr,styles.uac,bgColor('white'),ml(20),mr(20)]&#125; 技术栈typescript+eslint+redux+taro+react-native+mock 用法直接clone本项目进入项目根目录执行npm install操作,然后将third_changes对应目录里面的修改项替换项目根目录node_modules里面对应的组件,react-native原生端壳子Taro-demo-rn-shell.更多官方组件使用请移步京东Taro官方文档、微信小程序官方文档 先打开本地mock服务命令:npm run mock rn端运行命令:npm run dev:rm h5端运行命令:npm run dev:h5 微信小程序端运行命令:npm run dev:weapp 多端适配效果图 项目地址:https://github.com/bozaigao/Taro-demo","tags":[{"name":"react-native","slug":"react-native","permalink":"http://bozaigao.github.io/tags/react-native/"},{"name":"大前端","slug":"大前端","permalink":"http://bozaigao.github.io/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"Taro","slug":"Taro","permalink":"http://bozaigao.github.io/tags/Taro/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://bozaigao.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"H5","slug":"H5","permalink":"http://bozaigao.github.io/tags/H5/"}]},{"title":"解决Flutter项目运行报library not found for -libstdc++.6.0.9问题","date":"2019-12-30T03:39:22.000Z","path":"2019/12/30/解决Flutter项目运行报library-not-found-for-libstdc-6-0-9问题/","text":"在运行Flutter项目的时候由于里面第三方库引用了libstdc++.6.0.9这个库文件而导致项目运行报错问题，苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。 临时解决方法:将-libstdc++.6.0.9库文件导入xcode库文件，两个位置，一套是模拟器的，一套是设备的/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.0.sdk/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/-libstdc++.6.0.9下载地址:https://www.bozaigao.net/assets/libstdc++.6.0.9.tbd","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://bozaigao.github.io/tags/Flutter/"},{"name":"libstdc++.6.0.9","slug":"libstdc-6-0-9","permalink":"http://bozaigao.github.io/tags/libstdc-6-0-9/"}]},{"title":"react-native使用chrome调试WebView","date":"2019-12-25T00:31:29.000Z","path":"2019/12/25/react-native使用chrome调试WebView/","text":"react-native使用chrome调试WebView 如果使用的是google模拟器则直接在chrome浏览器输入:chrome://inspect直接进行调试，如果是Android真机则需要去chrome应用商店安装ADB Plugin插件； chrome应用商店下载插件需要翻墙，搭建教程：http://bozaigao.github.io/2019/11/07/使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子/","tags":[{"name":"react-native","slug":"react-native","permalink":"http://bozaigao.github.io/tags/react-native/"},{"name":"性能优化","slug":"性能优化","permalink":"http://bozaigao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"react-native热更新服务搭建","date":"2019-11-20T02:39:04.000Z","path":"2019/11/20/react-native热更新服务搭建/","text":"前言为了实现react-native项目的版本增量静默更新需求，需要使用热更新服务，之前用过微软的code-push更新服务，但是由于微软的Azure服务器是在国外，国内访问网速慢且不稳定，于是需要在公司阿里云的ECS上搭建自己的热更新服务. 热更新服务下载与文件修改 下载地址:https://github.com/lisong/code-push-server 然后主要是修改config/config.js 文件里里面的热更新包储存路径和下载基地址,最后将代码通过能够过ftp或者scp命令上传到服务端. config.js12345678910111213141516171819 db: &#123; username: process.env.RDS_USERNAME || \"root\", password: process.env.RDS_PASSWORD || null, database: process.env.DATA_BASE || \"codepush\", host: process.env.RDS_HOST || \"127.0.0.1\", port: process.env.RDS_PORT || 3306, dialect: \"mysql\", logging: false, operatorsAliases: false, &#125;, ...local: &#123; // Binary files storage dir, Do not use tmpdir and it's public download dir. storageDir: process.env.STORAGE_DIR || \"/codepush\", // Binary files download host address which Code Push Server listen to. the files storage in storageDir. downloadUrl: process.env.LOCAL_DOWNLOAD_URL || \"http://your_server_addrss:3000/download\", // public static download spacename. public: '/download' &#125; 服务端数据库配置 在服务器创建codepush数据库，然后use codepush选择数据库，执行source codepush-all.sql(在code-psuh-server sql目录下) 命令创建数据库表和字段. 启动热更新服务 先确保服务端安装好了node等环境，然后进入code-push-server目录执行npm install安装第三方依赖. 执行npm install -g forever安装forever插件，在项目目录执行 forever start ./bin/www来持久化热更新服务 forever作为node服务的守护进程，可以自动重启node服务，保证服务稳定运行","tags":[{"name":"热更新","slug":"热更新","permalink":"http://bozaigao.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"code-push-server","slug":"code-push-server","permalink":"http://bozaigao.github.io/tags/code-push-server/"}]},{"title":"使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子(Mac和iphone环境搭建)","date":"2019-11-07T08:10:04.000Z","path":"2019/11/07/使用阿里云ECS结合Shadowsocks搭建自己的专属翻墙梯子/","text":"前言 之前一用过Netfits、EasySSR、VyprVPN等一些第三方付费服务翻墙软件，但是自从国内政府严打VPN后陆陆续续翻墙的一些服务出现连接慢、网络延迟高、甚至服务直接不可用等状态，但是作为一名搞it的经常翻看国外技术文章的码农来说怎么能没有一款趁手的科学上网工具呢，由于第三方服务经常因为政策原因而变得不稳定，于是决定自己搭建一个翻墙工具。 1. 服务器端配置1.1 境外服务器或ECS(只要不在大陆就可以了，阿里云、腾讯云、aws等云服务商都提供此类服务，我自己购买的是阿里云香港的服务器) 如果服务器只是用来翻墙查下资料或者部署下个人博客的话选择最低配的，带宽选1M的足够使用。 1.2 服务端安装python版本的Shadowsocks 先安装pip git bash12curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"python get-pip.py 再通过pip安装Shadowsocks git bash12pip install --upgrade pippip install shadowsocks 创建Shadowsocks配置文件 12vi /etc/shadowsocks.jsonvi shadowsocks.json 配置文件内容如下： shadowsocks.json123456789&#123; \"server\":\"0.0.0.0\", --服务器IP，直接用0.0.0.0 \"server_port\":8888, --端口端口 \"local_address\": \"127.0.0.1\", --本地地址 \"local_port\":1080, --本地端口 \"password\":\"password\", --密码 \"timeout\":300, --超时时间 \"method\":\"aes-256-cfb\", --加密策略，有多重策略，具体自查&#125; 如果你想配置多个登录账号，可以进行如下配置： shadowsocks.json12345678910111213&#123; \"server\":\"0.0.0.0\", --服务器IP，直接用0.0.0.0 \"port_password\":&#123; \"8381\": \"password1\", \"8382\": \"password2\", \"8383\": \"password3\", \"8384\": \"password4\" &#125;, \"local_address\": \"127.0.0.1\", --本地地址 \"local_port\":1080, --本地端口 \"timeout\":300, --超时时间 \"method\":\"aes-256-cfb\", --加密策略，有多重策略，具体自查&#125; 注意：如果取成系统端口会导致服务启动失败 端口号一定不要随便取，如果取成了系统端口比如443会导致端口被占用从而导致服务启动失败 1.3 启动Shadowsocks服务 123456#启动ssserver -c /etc/shadowsocks.json -d start#停止ssserver -c /etc/shadowsocks.json -d stop#重启ssserver -c /etc/shadowsocks.json -d restart 如果发现Shadowsocks客户端一直连不上请到/var/log/shadowsocks.log查看服务报错日志，根据报错信息解决问题. 1.4 阿里云配置服务器安全入网策略 出网策略不用配置，安全组出方向默认允许所有访问，即从安全组内ECS访问外部都是放行的。 2. 本地电脑客户端配置2.1 Shadowsocks客户端下载 下载地址：https://github.com/shadowsocks/ShadowsocksX-NG/releases/ 2.2 安装压缩文件中直接就是Mac的app程序，解压后移动到Mac程序目录即可； 2.3 配置 3. 翻墙效果 Shadowsocks有PAC模式和全局模式:PAC模式：也就是智能分流模式，根据规则去匹配你访问的网站，国外网站走代理，国内网站不走代理；全局模式：国内、国外所有网站都走代理；我一般默认开PAC模式，这样加载国内网站速度会比较快，遇到网站加载很慢再开全局模式进行访问。注意：如果服务运行一段时间突然发现翻不了墙了，可能是阿里云那边做了限制，重新配置新的端口安全策略再重启Shadowsocks服务即可。 4. iphone安装Shadowrocketappstore中国区由于政策原因已经下架，直接登录美区账号搜索下载账号:4ssgit@Gmail.com 密码:V2Server如果登录失败请参考以下链接:https://shadowsockshelp.github.io/Shadowsocks/appleid.html进入Shadowrocket主界面后在首页点击添加服务器节点然后输入ip、端口号、加密方式和连接密码即可，配置以及登录twitter效果如下： 切记一定不要登录iCloud账号只需要登录appstore账号就可以了，不然手机被账号拥有者恶意锁定的话就无法解锁了。","tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://bozaigao.github.io/tags/Shadowsocks/"},{"name":"VPN","slug":"VPN","permalink":"http://bozaigao.github.io/tags/VPN/"},{"name":"翻墙","slug":"翻墙","permalink":"http://bozaigao.github.io/tags/%E7%BF%BB%E5%A2%99/"}]},{"title":"react-native版本升级","date":"2019-09-07T01:57:33.000Z","path":"2019/09/07/react-native版本升级/","text":"1. rn版本从0.51.0升级到0.60.4升级目的：rn从0.60.2引入了Hermes 新的js引擎，新的引擎从字节码预编译、无JIT、新的垃圾回收策略等优化了Android端apk大小，减少了内存使用，页面切换的帧率也比之前有了提高,本次分享的主题主要是解决在版本升级过程中遇到的问题。 2. 准备工作项目备份,初始化0.64.0版本的对应项目,保证初始化新项目iOS pod install、android 在target=0.28.0 clean rebuild正常运行,确保环境版本没问题,有问题的话直接查询react-native issue保证项目纯净，能正常运行; 3. js项目端升级 按照官方建议升级步骤,进入要升级的项目先执行react-native-git-upgare脚本自动升级命令,执行该命令会自动覆盖文件,一定记得要备份原项目,然后静静地等待升级完成,如果无法识别该命令,请先执行npm install react-native-git-upgare -g,结果升级中途报错无奈只能改为手动升级; 由于上述操作报错改为手动修改模式,将之前原项目src和package.json里面的依赖全部拷贝到新项目然后执行npm install先安装第三方依赖; 4. iOS原生端升级4.1 拷贝iOS原生文件 将iOS原生代码和Podfile依赖拷贝到对应位置,然后iOS执行pod install操作;此时有可能依赖的第三方组件会报一下错误: 4.2 修改并保存第三方库文件 将iOS第三方包*.podspec里面的s.dependency ‘React/Core’修改为 s.dependency ‘React-Core’然后再重新执行pod install,记得修改后的第三方内容需要单独拷贝出来不然每次执行npm install后都会被覆盖; 4.3 解决iOS原生端报错 如果静待pod install执行完毕没问题后，运行项目可能还会报以下错误: 直接将node_modules/react/React里面的React.xcodeproj拖入Libraries即可,切记不要将libReact.a也添加到项目中,否则会和pod依赖的React有多个类重复报错; 幸运的话项目应该可以直接跑起来了，但是跑起来后可能还会报以下运行报错: 进入项目目录执行 git bash1npm install --save babel-preset-react-native@5.0.2 4.4 解决js运行报错 解决了上一个问题还可能会报错: 在.babelrc文件添加以下代码 .babelrc1&#123;\"presets\": [\"module:metro-react-native-babel-preset\"]&#125; 然后执行： git bash1npm run start --reset-cache 或者 react-native start --reset-cache 最后模拟器运行不报错了但是真机运行却会崩溃，通过文件引用关系发现之前在js层封装了一个uuid的公共方法，但是rn0.60.4版本却会直接报错，关键是通过仅有的堆栈信息无法得知是uuid的问题，通过修改uuid名字得到解决； 5. Android原生端升级5.1 拷贝Android原生文件 将Android原生代码和app目录下的build.gradle依赖拷贝到对应位置,然后执行sync操作,rn0.60.4依赖的api版本是28，所以可能需要把support包改成AndroidX的引用方式; 5.2 解决Android端原生报错 修改完后build可能会报以下错误：通过点击AndroidManifest.xml=&gt;Merged Manifest,查看error信息解决 6. Android原生端继续报错在app build.gradle我去掉了 annotationProcessor ‘com.github.bumptech.glide:compiler:4.2.0’ 7. 升级后的效果android apk安装包比之前减少了4M左右，内存使用减少了30M左右，页面切换率提高了5～10帧/s","tags":[{"name":"react-native","slug":"react-native","permalink":"http://bozaigao.github.io/tags/react-native/"}]},{"title":"react-native性能优化","date":"2019-09-06T03:02:49.000Z","path":"2019/09/06/react-native性能优化/","text":"react-native log日志新能优化有两种方式第一种是使用babel-plugin-transform-remove-console插件在打包的时候自动去掉所有log信息，但是亲测在rn 0.51.0版本有效在0.60.3版本打包拆包后发现log信息并没有去掉，插件功能失效；第二种则是采用官方的建议 123456789if (!__DEV__) &#123; global.console = &#123; info: () =&gt; &#123;&#125;, log: () =&gt; &#123;&#125;, warn: () =&gt; &#123;&#125;, debug: () =&gt; &#123;&#125;, error: () =&gt; &#123;&#125; &#125;;&#125; 但其实这是不准确的，因为在console里面可能还有其他方法比如console.clear、console.dir、console.profile等，如果在第三方组件里面有用到这些方法调用则会找不到该方法从而导致未知错误，正确的处理方法如下： 123456789101112if (!__DEV__) &#123; global.console.info = () =&gt; &#123; &#125;; global.console.log = () =&gt; &#123; &#125;; global.console.warn = () =&gt; &#123; &#125;; global.console.debug = () =&gt; &#123; &#125;; global.console.error = () =&gt; &#123; &#125;; &#125;","tags":[{"name":"react-native","slug":"react-native","permalink":"http://bozaigao.github.io/tags/react-native/"},{"name":"性能优化","slug":"性能优化","permalink":"http://bozaigao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]}]